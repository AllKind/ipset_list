#!/bin/bash

# -----------------------------------------------------------------
# ipset set listing wrapper script
#
# https://github.com/AllKind/ipset_list
# -----------------------------------------------------------------

# Copyright (C) 2013 AllKind (AllKind@fastest.cc)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# -----------------------------------------------------------------
# Tested with ipset versions:
# 6.16.1
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Features (in addition to the native ipset options):
# - Calculate sum of set members.
# - Supress listing of headers.
# - List only members of a specified set.
# - Choose a delimiter character for separating members.
# - Show only set containing a specific (glob matching) header.
# - Match entries using a globbing or regex pattern.
# - Operate on a single, selected, or all sets.
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Examples:
# $0                 - no args, just list set names
# $0 -c              - show all set names and their member sum
# $0 -t              - show all sets, but headers only
# $0 -c -t setA      - show headers and member sum of setA
# $0 -i setA         - show only members entries of setA
# $0 -c -m setA setB - show members and sum of setA & setB
# $0 -a -c -d :      - show all sets members, sum and use `:' as entry delimiter
# $0 -a -c setA      - show all info of setA and its members sum
# $0 -c -m -d $'\n' setA - show members and sum of setA, delim with newline
# $0 -c -m -r -s setA    - show members resolved and sorted + sum of setA
# $0 -i -Fr "^210\..*" setA - show only members of setA matching the regex "^210\..*"
# $0 -a -c -Fh "Type:hash:ip" -Fr "^210\..*"
#+ - show all information of sets with type hash:ip,
#+ matching the regex "^210\..*", show match and members sum
#$0 -Fh Type:hash:ip -Fh "Header:family inet *" - show all set names, which are of
#+ type hash:ip and header of ipv4.
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Modify here
# -----------------------------------------------------------------
# path to ipset. defaults to `/sbin/ipset' if unset.
ipset="/sbin/ipset"

# default delimiter character. defaults to whitespace if unset.
delim=" "

# default read timeout
TMOUT=30
# -----------------------------------------------------------------

# bash check
if [ -z "$BASH" ]; then
	printf "\`BASH' variable is not available. Not running bash?\n"
	exit 1
fi

# shell settings
shopt -s extglob
set -f
set +o posix
set +u

# variables
export LC_ALL=C
readonly version=1.9
readonly me="${0//*\//}"
readonly oIFS="$IFS"
declare ips_version="" str_search=""
declare -i show_all=show_count=show_members=headers_only=names_only=isolate=match_on_header=0
declare -i in_header=found_set=glob_search=regex_search=member_count=match_count=i=x=idx=0
declare -a arr_opts arr_par arr_hcache arr_mcache arr_hsearch

while (($#)); do # parse cmd-line options
	case "$1" in
		-h) printf "\n ipset set listing wrapper script\n\n"
			printf '%s [option [opt-arg]] [set-name] [...]\n\n' "$me"
			printf '%s %s\n' "$me" "-h | -n"
			printf '%s %s\n' "$me" "-t [-c] [-Fh header-glob:value-glob] [...] [set-name] [...]"
			printf '%s %s\n' "$me" "-i [-r|-s] [-d char] [-Fg|-Fr pattern] set-name"
			printf '%s %s\n' "$me" "[-a|-c|-m|-r|-s] [-d char] [-Fh header-glob:value-glob] [...] [-Fg|-Fr pattern] [set-name] [...]"
			printf '\noptions:\n'
			printf '%s\n' '-a       show all information but with default delim (whitespace).'
			printf '%s\n' '-c       calculate members and match (-Fg|-Fr) sum.'
			printf '%s\n' '-d delim   delimiter character for separating member entries.'
			printf '%s\n' '-h       show this help text.'
			printf '%s\n' '-i       show only the members of a single set.'
			printf '%s\n' '-m       show set members.'
			printf '%s\n' "-n       show set names only (raw \`ipset list -n' output)."
			printf '%s\n' '-r       try to resolve ip addresses in the output (slow!).'
			printf '%s\n' '-s       print elements sorted (if supported by the set type).'
			printf '%s\n' '-t       show set headers only.'
			printf '%s\n' '-Fg pattern    show only sets and their members matching a glob pattern.'
			printf '%s\n' '-Fr pattern    show only sets and their members matching a regex (=~ operator) pattern.'
			printf '%s\n' '-Fh header-glob:value-glob [...]    show only sets containing one or more (glob) matching header entries.'
			printf '%s\n\n' '-v       version information.'
			exit 0
		;;
		-a) show_all=1 # like `ipset list', but with $delim as delim
			shift
		;;
		-c) show_count=1 # show sum of member entries
			shift
		;;
		-i) isolate=1 # show only members of a single set
			shift
		;;
		-m) show_members=1 # show set members
			shift
		;;
		-n) names_only=1 # only list set names
			shift
		;;
		-t) headers_only=1 # show only set headers
			shift
		;;
		-s|-r) arr_par[i++]="$1" # ipset sort & resolve options are passed on
			shift
		;;
		-d) if [[ -z $2 ]]; then # delimiter char for separating member entries
				printf "delim character is missing\n" >&2
				exit 2
			else
				if ((${#2} > 1)); then
					printf "only one character is allowed as delim\n" >&2
					exit 2
				fi
				delim="$2"
				shift 2
			fi
		;;
		-o) if [[ $2 != plain ]]; then
				printf "only plain output is supported\n" >&2
				exit 2
			else
				shift 2
			fi
		;;
		-Fg) glob_search=1 # find entry with globbing pattern
			if [[ -z $2 ]]; then
				printf "glob pattern is missing\n" >&2
				exit 2
			else
				str_search="$2"
				shift 2
			fi
		;;
		-Fr) regex_search=1 # find entry with regex pattern
			if [[ -z $2 ]]; then
				printf "regex pattern is missing\n" >&2
				exit 2
			else
				str_search="$2"
				shift 2
			fi
		;;
		-Fh) let match_on_header+=1 # show only sets, which contain a matching header entry
			if [[ -z $2 ]]; then
				printf "header pattern is missing\n" >&2
				exit 2
			else
				if [[ $2 = *:* ]]; then
					arr_hsearch[x++]="$2"
					shift 2
				else
					printf "invalid format of header descriptor. expecting: \`name:value'.\n" >&2
					exit 2
				fi
			fi
		;;
		-\!|-f) printf "unsupported option: \`$1'\n" >&2
			exit 2
		;;
		-v) printf "%s version %s\n" "$me" "$version"
			exit 0
		;;
		*) break
	esac
done

# check for ipset program and version
[[ -x ${ipset:=/sbin/ipset} ]] || {
	printf "ipset binary \`%s' does not exist, or is not executable. check \`ipset' variable.\n" "$ipset" >&2
	exit 1
}
ips_version="$("$ipset" --version)"
ips_version="${ips_version#ipset v}"
ips_version="${ips_version%%.*}"
if [[ $ips_version != +([[:digit:]]) ]]; then
	printf "failed retrieving ipset version. expected digits, got: \`%s'.\n" "$ips_version" >&2
	exit 1
fi
if ((ips_version < 6)); then
	printf "found version \`%s' - ipset versions from 6.x and upwards are supported\n" "$ips_version" >&2
	exit 1
fi

# option logic
if ((names_only && headers_only)); then
	printf "options -n and -t are mutually exclusive\n" >&2
	exit 2
elif ((headers_only)); then
	if ((show_members || show_all || isolate)); then
		printf "options -t and -a|-i|-m are mutually exclusive\n" >&2
		exit 2
	fi
elif ((names_only)); then
	if ((show_count || show_members || show_all || isolate || match_on_header)); then
		printf "options -n and -a|-c|-i|-m|-Fh are mutually exclusive\n" >&2
		exit 2
	fi
	# raw ipset output
	"$ipset" list -n
	exit $?
fi
if ((isolate)); then
	if ((show_count || show_all)); then
		printf "options -i and -a|-c are mutually exclusive\n" >&2
		exit 2
	fi
fi
if ((glob_search || regex_search)); then
	if ((glob_search && regex_search)); then
		printf "options -Fg and -Fr are mutually exclusive\n" >&2
		exit 2
	fi
	if ! ((show_members || show_all || isolate)); then
		printf "glob or regex search requires any of: -a|-i|-m\n" >&2
		exit 2
	fi
fi

# sets to work on (no arg means all sets)
if [[ $1 ]]; then
	if ((isolate)); then
		if (($# != 1)); then
			printf "option -i is only valid for a single set\n" >&2
			exit 2
		fi
	fi
	arr_opts=("$@")
else
	if ((isolate)); then
		printf "option -i is only valid for a single set\n" >&2
		exit 2
	fi
	while IFS=$'\n' read -r; do
		arr_opts[idx++]="$REPLY"
	done < <("$ipset" list -n)
fi

# read sets
for idx in "${!arr_opts[@]}"; do found_set=0 arr_hcache=() arr_mcache=()
	while read -r; do
		case "$REPLY" in
			"") : ;;
			Name:*) # header opened (set found)
				if ((in_header)); then
					printf "unexpected entry: \`%s' - header not closed?\n" "$REPLY" >&2
					exit 1
				fi
				in_header=1 found_set=1 found_header=0 member_count=0 match_count=0 i=0 x=0 
				if ! ((isolate)); then
					if ! ((headers_only || show_members || show_all || show_count || match_on_header)); then
						in_header=0 
						arr_hcache[x++]="$REPLY"
						break # nothing to show but the names
					else
						arr_hcache[x++]=$'\n'"$REPLY"
					fi
				fi
			;;
			Members:*) # closes header (if not `ipset -t')
				if ! ((in_header)); then
					printf "unexpected entry: \`%s' - header not opened?\n" "$REPLY" >&2
					exit 1
				fi
				in_header=0
				if ((match_on_header)); then
					if ! ((found_header == match_on_header)); then
						found_set=0
						break # set does not contain wanted header
					fi
				fi
				if ((show_all)); then
					arr_hcache[x++]="$REPLY"
				fi
			;;
			*) # either in-header, or member entry
				if ((found_set)); then
					if ((in_header)); then # we should be in the header
						if ((match_on_header && found_header < match_on_header)); then # match on an header entry
							for idx in ${!arr_hsearch[@]}; do
								if [[ ${REPLY%%:*} = ${arr_hsearch[idx]%%:*} && ${REPLY#*: } = ${arr_hsearch[idx]#*:} ]]; then
									let found_header+=1
								fi
							done
						fi
						if ((headers_only || show_all)); then
							arr_hcache[x++]="$REPLY"
						fi
					else # this should be a member entry
						if ((headers_only && show_count == 0)); then
							break # nothing more to do for this set
						elif ((show_members || show_all || isolate)); then
							if ((glob_search)); then
								if [[ $REPLY = $str_search ]]; then let match_count+=1
									arr_mcache[i++]="$REPLY"
								fi
							elif ((regex_search)); then
								if [[ $REPLY =~ $str_search ]]; then let match_count+=1
									arr_mcache[i++]="$REPLY"
								fi
							else
								arr_mcache[i++]="$REPLY"
							fi
						fi
						let member_count+=1
					fi
				else
					printf "no set opened by \`Name:'. unexpected entry \`%s'.\n" "$REPLY" >&2
					exit 1
				fi
		esac
	done < <("$ipset" list "${arr_opts[idx]}" "${arr_par[@]}")
	if ((found_set)); then # print gathered information
		if ((glob_search || regex_search)) && ((match_count == 0)); then
			continue # glob or regex search didn't match
		fi
		if ((${#arr_hcache[@]})); then
			printf "%s\n" "${arr_hcache[@]}"
		fi
		if ((${#arr_mcache[@]})); then
			IFS="${delim:= }"
			printf "%s" "${arr_mcache[*]}"
			IFS="$oIFS"
			printf "\n"
		fi
		if ((show_count)); then
			if ((glob_search || regex_search)); then
				printf "Match count: %d\n" $match_count
			fi
			printf "Member count: %d\n" $member_count
		fi
	fi
done

