#!/bin/bash

# -----------------------------------------------------------------
# ipset set listing wrapper script
#
# https://github.com/AllKind/ipset_list
# -----------------------------------------------------------------

# Copyright (C) 2013 AllKind (AllKind@fastest.cc)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# -----------------------------------------------------------------
# Tested with ipset versions:
# 6.16.1
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Features (in addition to the native ipset options):
# - Calculate sum of set members (and match on that count).
# - List only members of a specified set.
# - Choose a delimiter character for separating members.
# - Show only sets containing a specific (glob matching) header.
# - Arithmetic comparison on headers with an integer value.
# - Match members using a globbing or regex pattern.
# - Supress listing of (glob matching) headers.
# - Supress listing of members matching a glob or regex pattern.
# - Calculate the total size in memory of all matching sets.
# - Calculate the total amount of all matching and traversed sets.
# - Operate on a single, selected, or all sets.
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Examples:
# $0                 - no args, just list set names
# $0 -c              - show all set names and their member sum
# $0 -t              - show all sets, but headers only
# $0 -c -t setA      - show headers and member sum of setA
# $0 -i setA         - show only members entries of setA
# $0 -c -m setA setB - show members and sum of setA & setB
# $0 -a -c -d :      - show all sets members, sum and use `:' as entry delimiter
# $0 -a -c setA      - show all info of setA and its members sum
# $0 -c -m -d $'\n' setA - show members and sum of setA, delim with newline
# $0 -c -m -r -s setA    - show members resolved and sorted + sum of setA
# $0 -i -Fr "^210\..*" setA - show only members of setA matching the regex "^210\..*"
# $0 -a -c -Fh "Type:hash:ip" -Fr "^210\..*"
#+ - show all information of sets with type hash:ip,
#+ matching the regex "^210\..*", show match and members sum
# $0 -Fh Type:hash:ip -Fh "Header:family inet *" - show all set names, which are of
#+ type hash:ip and header of ipv4.
# $0 -Fi References:0    - show all sets with 0 references
# $0 -Hr 0               - shortcut for -Fi References:0
# $0 -Ht "!(hash:ip)"    - show sets which are not of type hash:ip
# $0 -Ht "!(bitmap:*)"   - show sets wich are not of any bitmap type
# $0 -Hr 2 -Hv 0 -Hs \>10000 -Ht hash:ip    - find sets with 2 references,
#+ revision of 0, size in memory greater than 10000 and of type hash:ip
# $0 -Mc 0           - show sets with zero members 
# $0 -Mc '>=100'     - show sets with a member count greater or equal to 100
# $0 -t -Xh "Revision:*" -Xh "References:*"
#+ - show all sets headers, but exclude Revision and References entries.
# $0 -c -m -Xg "210.*" setA - show members of setA, but supress listing of entries
#+ matching the glob pattern "210.*", show count of excluded and total members.
# $0 -Tm             - calculate total size in memory of all sets.
# $0 -t -Tm -Xh "@(Type|Re*|Header):*" 
#+ show all sets headers, but supress all but name and memsize entry,
#+ calculate the total memory size of all sets.
# $0 -Cs -Ht "hash:*"    - find sets of any hash type, calculate their sum.
# $0 -Ts             - show all set names and total count of sets.
# $0 -c -t -Cs -Ts -Xh "@(Size*|Re*|Header):*" -Ht "!(bitmap:*)"
#+ find all sets not of any bitmap type, count their members sum,
#+ display only the 'Type' header,
#+ count amount of matching and traversed sets.
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Modify here
# -----------------------------------------------------------------
# path to ipset. defaults to `/sbin/ipset' if unset.
ipset="/sbin/ipset"

# default delimiter character. defaults to whitespace if unset.
delim=" "

# default read timeout
TMOUT=30
# -----------------------------------------------------------------

# bash check
if [ -z "$BASH" ]; then
	printf "\`BASH' variable is not available. Not running bash?\n" >&2
	exit 1
fi

# shell settings
shopt -s extglob
set -f
set +o posix
set +u

# variables
export LC_ALL=C
readonly version=2.4
readonly me="${0//*\//}"
readonly oIFS="$IFS"
declare ips_version="" str_search="" str_match_on_msum="" str_xclude="" str_hval str_op
declare -i show_all=show_count=show_members=headers_only=names_only=isolate=calc_mem=count_sets=sets_total=0
declare -i match_on_header=glob_search=regex_search=member_count=match_count=do_count=0
declare -i exclude_header=glob_xclude_element=glob_xclude_element=0
declare -i in_header=found_set=found_hxclude=xclude_count=mem_total=mem_tmp=set_count=sets_sum=i=x=idx=0
declare -a arr_opts arr_par arr_hcache arr_mcache arr_hsearch arr_hsearch_int arr_hxclude

while (($#)); do # parse cmd-line options
	case "$1" in
		-\?|-h) printf "\n\tipset set listing wrapper script\n\n"
			printf '%s [option [opt-arg]] [set-name] [...]\n\n' "$me"
			printf '%s %s\n' "$me" "{-?|-h} | -n"
			printf '%s %s\n' "$me" "[-i|-r|-s] [-d char] [{-Fg|-Fr}|{-Xg|-Xr} pattern] set-name"
			printf '%s %s\n\t%s\n\t%s\n\t%s\n\t%s\n\t%s\n' "$me"\
			   	"[-t|-c|-Cs|-Tm|-Ts] [-Fh header-glob:value-glob] [...]"\
			   	"[-Fi header-glob:[!|<|>|<=|>=]value] [...]"\
			   	"[-Fg|-Fr pattern] [-Ht type-glob]"\
			   	"[-Hr|-Hs|-Hv [!|<|>|<=|>=]value]"\
			   	"[-Mc [!|<|>|<=|>=]value]"\
			   	"[-Xh header-glob:value-glob] [...] [set-name] [...]"
			printf '%s %s\n\t%s\n\t%s\n\t%s\n\t%s\n\t%s\n\t%s\n\t%s\n' "$me"\
			   	"[-a|-c|-m|-r|-s|-Cs|-Tm|-Ts] [-d char]"\
			   	"[-Fh header-glob:value-glob] [...]"\
			   	"[-Fi header-glob:[!|<|>|<=|>=]value] [...]"\
			   	"[-Fg|-Fr pattern] [-Ht type-glob]"\
			   	"[-Hr|-Hs|-Hv [!|<|>|<=|>=]value]"\
			   	"[-Mc [!|<|>|<=|>=]value]"\
				"[-Xh header-glob:value-glob] [...]"\
			   	"[-Xg|-Xr pattern] [set-name] [...]"
			printf 'options:\n'
			printf '%s\n' '-a       show all information but with default delim (whitespace).'
			printf '%s\n' '-c       calculate members and match (-Fg|-Fr) sum.'
			printf '%s\n' '-d delim       delimiter character for separating member entries.'
			printf '%s\n' '-h|-?    show this help text.'
			printf '%s\n' '-i       show only the members of a single set.'
			printf '%s\n' '-m       show set members.'
			printf '%s\n' "-n       show set names only (raw \`ipset list -n' output)."
			printf '%s\n' '-r       try to resolve ip addresses in the output (slow!).'
			printf '%s\n' '-s       print elements sorted (if supported by the set type).'
			printf '%s\n' '-t       show set headers only.'
			printf '%s\n' '-v       version information.'
			printf '%s\n' '-Cs      count amount of matching sets.'
			printf '%s\n' '-Fg pattern    match on members using a [ext]glob pattern.'
			printf '%s\n' '-Fr pattern    match on members using a regex (=~ operator) pattern.'
			printf '%s\n\t%s\n' '-Fh header-glob:value-glob [...]'\
				'show sets containing one or more [ext]glob matching headers.'
			printf '%s\n\t%s\n' '-Fi header-glob:[!|<|>|<=|>=]value [...]'\
				'show sets matching one or more integer valued header entries.'
			printf '%s\n' '-Ht set-type-glob         match on set type.'
			printf '%s\n' '-Hr [!|<|>|<=|>=]value    match on number of references (value=int).'
			printf '%s\n' '-Hs [!|<|>|<=|>=]value    match on size in memory (value=int).'
			printf '%s\n' '-Hv [!|<|>|<=|>=]value    match on revision number (value=int).'
			printf '%s\n' '-Mc [!|<|>|<=|>=]value    match on member count (value=int).'
			printf '%s\n' '-Tm      calculate total memory usage of all matching sets.'
			printf '%s\n' '-Ts      count amount of traversed sets.'
			printf '%s\n\t%s\n' '-Xh header-glob:value-glob [...]'\
				'exclude one or more [ext]glob matching header entries.'
			printf '%s\n' '-Xg pattern    exclude members matching a [ext]glob pattern.'
			printf '%s\n' '-Xr pattern    exclude members matching a regex pattern.'
			exit 0
		;;
		-a) show_all=1 # like `ipset list', but with $delim as delim
			shift
		;;
		-c) show_count=1 # show sum of member entries
			shift
		;;
		-i) isolate=1 # show only members of a single set
			shift
		;;
		-m) show_members=1 # show set members
			shift
		;;
		-n) names_only=1 # only list set names
			shift
		;;
		-t) headers_only=1 # show only set headers
			shift
		;;
		-s|-r) arr_par[i++]="$1" # ipset sort & resolve options are passed on
			shift
		;;
		-d) if [[ -z $2 ]]; then # delimiter char for separating member entries
				printf "delim character of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				if ((${#2} > 1)); then
					printf "only one character is allowed as delim\n" >&2
					exit 2
				fi
				delim="$2"
				shift 2
			fi
		;;
		-o) if [[ $2 != plain ]]; then
				printf "only plain output is supported\n" >&2
				exit 2
			else
				shift 2
			fi
		;;
		-Cs) count_sets=1 # calculate total count of matching sets
			shift
		;;
		-Fg) glob_search=1 # find entry with globbing pattern
			if [[ -z $2 ]]; then
				printf "glob pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				str_search="$2"
				shift 2
			fi
		;;
		-Fr) regex_search=1 # find entry with regex pattern
			if [[ -z $2 ]]; then
				printf "regex pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				str_search="$2"
				shift 2
			fi
		;;
		-Fh) let match_on_header+=1 # show only sets, which contain a matching header entry
			if [[ -z $2 ]]; then
				printf "header pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				if [[ $2 = *:* ]]; then
					arr_hsearch[x++]="$2"
					shift 2
				else
					printf "invalid format of header descriptor. expecting: \`*:*'.\n" >&2
					exit 2
				fi
			fi
		;;
		-Fi) let match_on_header+=1 # show only sets, containing a matching (int compare) header entry
			if [[ -z $2 ]]; then
				printf "header pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				if [[ $2 = *:?(\!|<|>|<=|>=)+([[:digit:]]) ]]; then
					arr_hsearch_int[idx++]="$2"
					shift 2
				else
					printf "invalid format of header descriptor. expecting: \`name:[!|<|>|<=|>=]value'.\n" >&2
					exit 2
				fi
			fi
		;;
		-Hr) let match_on_header+=1 # shortcut for -Fi References:...
			if [[ -z $2 ]]; then
				printf "header pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				if [[ $2 = ?(\!|<|>|<=|>=)+([[:digit:]]) ]]; then
					arr_hsearch_int[idx++]="References:$2"
					shift 2
				else
					printf "invalid format of references header descriptor. expecting: \`[!|<|>|<=|>=]value'.\n" >&2
					exit 2
				fi
			fi
		;;
		-Hs) let match_on_header+=1 # shortcut for -Fi "Size in Memory:..."
			if [[ -z $2 ]]; then
				printf "header pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				if [[ $2 = ?(\!|<|>|<=|>=)+([[:digit:]]) ]]; then
					arr_hsearch_int[idx++]="Size in memory:$2"
					shift 2
				else
					printf "invalid format of memsize header descriptor. expecting: \`[!|<|>|<=|>=]value'.\n" >&2
					exit 2
				fi
			fi
		;;
		-Ht) let match_on_header+=1 # shortcut for -Fh Type:x:y
			if [[ -z $2 ]]; then
				printf "header pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				if [[ $2 = *:* ]]; then
					arr_hsearch[x++]="Type:$2"
					shift 2
				else
					printf "invalid format of set type descriptor. expecting: \`*:*'.\n" >&2
					exit 2
				fi
			fi
		;;
		-Hv) let match_on_header+=1 # shortcut for -Fi Revision:...
			if [[ -z $2 ]]; then
				printf "header pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				if [[ $2 = ?(\!|<|>|<=|>=)+([[:digit:]]) ]]; then
					arr_hsearch_int[idx++]="Revision:$2"
					shift 2
				else
					printf "invalid format of revision header descriptor. expecting: \`[!|<|>|<=|>=]value'.\n" >&2
					exit 2
				fi
			fi
		;;
		-Mc) do_count=1 # match on the count of members
			if [[ -z $2 ]]; then
				printf "value pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				if [[ $2 = ?(\!|<|>|<=|>=)+([[:digit:]]) ]]; then
					str_match_on_msum="$2"
					shift 2
				else
					printf "invalid format of match on member count value. expecting: \`[!|<|>|<=|>=]value'.\n" >&2
					exit 2
				fi
			fi
		;;
		-Tm) calc_mem=1 # caculate total memory usage of all matching sets
			shift
		;;
		-Ts) sets_total=1 # caculate sum of all traversed sets
			shift
		;;
		-Xh) exclude_header=1 # don't show certain headers
			if [[ -z $2 ]]; then
				printf "header pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				if [[ $2 = *:* ]]; then
					arr_hxclude[${#arr_hxclude[@]}]="$2"
					shift 2
				else
					printf "invalid format of header descriptor. expecting: \`*:*'.\n" >&2
					exit 2
				fi
			fi
		;;
		-Xg) glob_xclude_element=1 # supress printing of matching members using a globbing pattern
			if [[ -z $2 ]]; then
				printf "glob pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				str_xclude="$2"
				shift 2
			fi
		;;
		-Xr) regex_xclude_element=1 # supress printing of matching members using a regex pattern
			if [[ -z $2 ]]; then
				printf "regex pattern of option \`%s' is missing\n" "$1" >&2
				exit 2
			else
				str_xclude="$2"
				shift 2
			fi
		;;
		-\!|-f) printf "unsupported option: \`$1'\n" >&2
			exit 2
		;;
		-v) printf "%s version %s\n" "$me" "$version"
			exit 0
		;;
		*) break
	esac
done
declare -i i=x=idx=0

# check for ipset program and version
[[ -x ${ipset:=/sbin/ipset} ]] || {
	printf "ipset binary \`%s' does not exist, or is not executable. check \`ipset' variable.\n" "$ipset" >&2
	exit 1
}
ips_version="$("$ipset" --version)"
ips_version="${ips_version#ipset v}"
ips_version="${ips_version%%.*}"
if [[ $ips_version != +([[:digit:]]) ]]; then
	printf "failed retrieving ipset version. expected digits, got: \`%s'.\n" "$ips_version" >&2
	exit 1
fi
if ((ips_version < 6)); then
	printf "found version \`%s' - ipset versions from 6.x and upwards are supported\n" "$ips_version" >&2
	exit 1
fi

# option logic
if ((names_only)); then
	if ((headers_only||show_count||show_members||show_all||isolate||\
		match_on_header||do_count||glob_search||regex_search||calc_mem||\
		glob_xclude_element||regex_xclude_element||count_sets||sets_total))
   	then
		printf "option -n does not allow another option.\n" >&2
		exit 2
	fi
	# raw ipset output
	"$ipset" list -n
	exit $?
fi
if ((headers_only)); then
	if ((show_members || show_all || isolate)); then
		printf "options -t and -a|-i|-m are mutually exclusive\n" >&2
		exit 2
	fi
fi
if ((isolate)); then
	if ((show_count || show_all || calc_mem || count_sets)); then
		printf "options -i and -a|-c|-Cs|-Tm are mutually exclusive\n" >&2
		exit 2
	fi
fi
if ((glob_search || regex_search)); then
	if ((glob_search && regex_search)); then
		printf "options -Fg and -Fr are mutually exclusive\n" >&2
		exit 2
	fi
	if ((glob_xclude_element || regex_xclude_element)); then
		printf "options -Fg|-Fr and -Xg|-Xr are mutually exclusive\n" >&2
		exit 2
	fi
fi
if ((exclude_header)); then
	if ! ((headers_only || show_all)); then
		printf "option -Xh requires -a or -t\n" >&2
		exit 2
	fi
fi
if ((glob_xclude_element || regex_xclude_element)); then
	if ! ((show_members || show_all || isolate)); then
		printf "options -Fg|-Fr require any of -a|-i|-m\n" >&2
		exit 2
	fi
fi

# sets to work on (no arg means all sets)
if [[ $1 ]]; then
	if ((isolate)); then
		if (($# != 1)); then
			printf "option -i is only valid for a single set\n" >&2
			exit 2
		fi
	fi
	arr_opts=("$@")
else
	if ((isolate)); then
		printf "option -i is only valid for a single set\n" >&2
		exit 2
	fi
	while IFS=$'\n' read -r; do
		arr_opts[idx++]="$REPLY"
	done < <("$ipset" list -n)
fi

# read sets
for idx in "${!arr_opts[@]}"; do found_set=0 arr_hcache=() arr_mcache=()
	while read -r; do
		case "$REPLY" in
			"") : ;;
			Name:*) # header opened (set found)
				if ((in_header)); then
					printf "unexpected entry: \`%s' - header not closed?\n" "$REPLY" >&2
					exit 1
				fi
				let sets_sum+=1
				in_header=1 found_set=1 found_header=0 member_count=0 match_count=0 xclude_count=0 mem_tmp=0 i=0 x=0 
				if ! ((isolate)); then # if showing members only, continue without saving any header data
					if ! ((headers_only||show_members||show_all||show_count||match_on_header||do_count||calc_mem||glob_search||regex_search))
				   	then
						in_header=0 
						arr_hcache[x++]="$REPLY"
						break # nothing to show but the names
					else
						arr_hcache[x++]=$'\n'"$REPLY"
					fi
				fi
			;;
			Members:*) # closes header (if not `ipset -t')
				if ! ((in_header)); then
					printf "unexpected entry: \`%s' - header not opened?\n" "$REPLY" >&2
					exit 1
				fi
				in_header=0
				if ((match_on_header)); then
					if ((found_header != match_on_header)); then found_set=0
						break # set does not contain wanted header
					fi
				fi
				if ((show_all)); then
					arr_hcache[x++]="$REPLY"
				fi
			;;
			*) # either in-header, or member entry
				if ! ((found_set)); then
					printf "no set opened by \`Name:'. unexpected entry \`%s'.\n" "$REPLY" >&2
					exit 1
				fi
				if ((in_header)); then # we should be in the header
					if ((match_on_header && found_header < match_on_header)); then # match on an header entry
						for idx in ${!arr_hsearch[@]}; do # string compare
							if [[ ${REPLY%%:*} = ${arr_hsearch[idx]%%:*} && ${REPLY#*: } = ${arr_hsearch[idx]#*:} ]]
							then let found_header+=1
							fi
						done
						for idx in ${!arr_hsearch_int[@]}; do # int compare
							if [[ ${REPLY%%:*} = ${arr_hsearch_int[idx]%%:*} ]]; then # header name matches
								if [[ ${REPLY#*: } != +([[:digit:]]) ]]; then
									printf "header value \`%s' is not an integer.\n" "${REPLY#*: }" >&2
									exit 1
								fi
								str_hval="${arr_hsearch_int[idx]#*:}"
								str_op="${str_hval//[[:digit:]]}" # compare operator defaults to `=='
								[[ ${str_op:===} = \! ]] && str_op='!='
								if ((${REPLY#*: } $str_op ${str_hval//[[:punct:]]})); then
									let found_header+=1
								fi
							fi
						done
					fi
					if ((calc_mem)); then
						if [[ ${REPLY%%:*} = "Size in memory" ]]; then
							if [[ ${REPLY#*: } != +([[:digit:]]) ]]; then
								printf "header value \`%s' is not an integer.\n" "${REPLY#*: }" >&2
								exit 1
							fi
							# save to temp, in case we throw away the set, if it doesn't match other criteria
							mem_tmp=${REPLY#*: }
						fi
					fi
					if ((headers_only || show_all)); then found_hxclude=0
						if ((exclude_header)); then # don't show certain headers
							for idx in ${!arr_hxclude[@]}; do
								if [[ ${REPLY%%:*} = ${arr_hxclude[idx]%%:*} && ${REPLY#*: } = ${arr_hxclude[idx]#*:} ]]
								then found_hxclude=1
									break
								fi
							done
						fi
						if ! ((found_hxclude)); then
							arr_hcache[x++]="$REPLY"
						fi
					fi
				else # this should be a member entry
					if ((show_members || show_all || isolate || glob_search || regex_search)); then
						if ((glob_search)); then # show sets with matching members
							if [[ $REPLY = $str_search ]]; then let match_count+=1
								if ((show_members || show_all || isolate)); then
									arr_mcache[i++]="$REPLY"
								fi
							fi
						elif ((regex_search)); then # show sets with matching members
							if [[ $REPLY =~ $str_search ]]; then let match_count+=1
								if ((show_members || show_all || isolate)); then
									arr_mcache[i++]="$REPLY"
								fi
							fi
						else
							if ((glob_xclude_element)); then # exclude matching members
								if ! [[ $REPLY = $str_xclude ]]; then
									arr_mcache[i++]="$REPLY"
								else let xclude_count+=1
								fi
							elif ((regex_xclude_element)); then # exclude matching members
								if ! [[ $REPLY =~ $str_xclude ]]; then
									arr_mcache[i++]="$REPLY"
								else let xclude_count+=1
								fi
							else
								arr_mcache[i++]="$REPLY"
							fi
						fi
					else # nothing to show or search for, do we need to count members?
						if ! ((show_count || do_count)); then
							break # nothing more to do for this set
						fi
					fi
					let member_count+=1
				fi
		esac
	done < <("$ipset" list "${arr_opts[idx]}" "${arr_par[@]}")
	if ((found_set)); then # print gathered information
		if ((glob_search || regex_search)) && ((match_count == 0)); then
			continue # glob or regex search didn't match
		fi
		if [[ $str_match_on_msum ]]; then # match on member sum
			str_op="${str_match_on_msum//[[:digit:]]}"
			[[ ${str_op:===} = \! ]] && str_op='!='
			if ! (($member_count $str_op ${str_match_on_msum//[[:punct:]]})); then
				continue # does not match
			fi
		fi
		let set_count+=1 # count amount of matching sets
		if ((calc_mem)); then
			let mem_total+=$mem_tmp
		fi
		if ((${#arr_hcache[@]})); then
			printf "%s\n" "${arr_hcache[@]}"
		fi
		if ((${#arr_mcache[@]})); then
			IFS="${delim:= }"
			printf "%s" "${arr_mcache[*]}"
			IFS="$oIFS"
			printf "\n"
		fi
		if ((show_count)); then
			if ((glob_search || regex_search)); then
				printf "Match count: %d\n" $match_count
			fi
			if ((glob_xclude_element || regex_xclude_element)); then
				printf "Exclude count: %d\n" $xclude_count
			fi
			printf "Member count: %d\n" $member_count
		fi
	fi
done
if ((count_sets || calc_mem || sets_total)); then
	printf "\n"
	if ((count_sets)); then
		printf "Count of all matched sets: %d\n" $set_count
	fi
	if ((sets_total)); then
		printf "Count of all traversed sets: %d\n" $sets_sum
	fi
	if ((calc_mem)); then
		printf "Total memory size of all matched sets: %d\n" $mem_total
	fi
fi
