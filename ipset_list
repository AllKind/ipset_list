#!/usr/bin/env bash

# -----------------------------------------------------------------
# ipset set listing wrapper script
#
# https://github.com/AllKind/ipset_list
# https://sourceforge.net/projects/ipset-list/
# -----------------------------------------------------------------

# Copyright (C) 2013-2016 Mart Frauenlob aka AllKind (AllKind@fastest.cc)
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

# -----------------------------------------------------------------
# Compatible with ipset version 6+
# Tested with ipset versions:
# 6.24, 6.27
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Features (in addition to the native ipset options):
# - Calculate sum of set members (since v6.25 using built in values)
# + and match on that count.
# - List only members of a specified set.
# - Choose a delimiter character for separating members.
# - Show only sets containing a specific (glob matching) header.
# - Arithmetic comparison on headers with an integer value.
# - Arithmetic comparison on flags of the headers 'Header' field.
# - Arithmetic comparison on member options with an integer value.
# - Match members using a globbing or regex pattern.
# - Suppress listing of (glob matching) sets.
# - Suppress listing of (glob matching) headers.
# - Suppress listing of members matching a glob or regex pattern.
# - Suppress listing of member options.
# - Calculate the total size in memory of all matching sets.
# - Calculate the amount of matching, excluded and traversed sets.
# - Test for existence of multiple elements over multiple sets.
# - Operate on a single, selected, or all sets.
# - Colorize the output.
# - A wizard based interactive mode.
# - Programmable completion is included to make usage easier and faster.
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Examples:
# $0                   - no args, just list set names
# $0 -c                - show all set names and their member sum
# $0 -t                - show all sets, but headers only
# $0 -c -t setA        - show headers and member sum of setA
# $0 -i setA           - show only members entries of setA
# $0 -c -m setA setB   - show members and sum of setA & setB
# $0 -a -c -d :        - show all sets members, sum and use `:' as entry delimiter
# $0 -a -c setA        - show all info of setA and its members sum
# $0 -c -m -d $'\n' setA - show members and sum of setA, delim with newline
# $0 -m -r -s setA     - show members of setA resolved and sorted
# $0 -Ts               - show all set names and total count of sets.
# $0 -Tm               - calculate total size in memory of all sets.
# $0 -Mc 0             - show sets with zero members
# $0 -Fi References:0  - show all sets with 0 references
# $0 -Hr 0             - shortcut for `-Fi References:0'
# $0 -Xs setA -Xs setB - show all set names, but exclude setA and setB.
# $0 -Xs "set[AB]"     - show all set names, but exclude setA and setB.
# $0 -Cs -Ht "hash:*"  - find sets of any hash type, count their amount.
# $0 -Ht "!(hash:ip)"  - show sets which are not of type hash:ip
# $0 -Ht "!(bitmap:*)" - show sets wich are not of any bitmap type
# $0 -i -Fr "^210\..*" setA - show only members of setA matching the regex "^210\..*"
# $0 -Mc \>=100 -Mc \<=150  - show sets with a member count greater or equal to 100
#+ and not greater than 150.
# $0 -a -c -Fh "Type:hash:ip" -Fr "^210\..*"
#+ - show all information of sets with type hash:ip,
#+ matching the regex "^210\..*", show match and members sum.
#
# $0 -m -Fg "!(210.*)" setA
#+ show members of setA excluding the elements matching the negated glob.
#
# $0 -Hr \>=1 -Hv 0 -Hs \>10000   - find sets with at least one reference,
#+ revision of 0 and size in memory greater than 10000
#
# $0 -Fh Type:hash:ip -Fh "Header:family inet *"
#+ - show all set names, which are of type hash:ip and header of ipv4.
#
# $0 -t -Xh "Revision:*" -Xh "References:*"
#+ - show all sets headers, but exclude Revision and References entries.
#
# $0 -t -Ht "!(bitmap:@(ip|port))" -Xh "!(Type):*"   - show all sets that are
#+ neither of type bitmap:ip or bitmap:port, suppress all but the type header.
#
# $0 -c -m -Xg "210.*" setA - show members of setA, but suppress listing of entries
#+ matching the glob pattern "210.*", show count of excluded and total members.
#
# $0 -t -Tm -Xh "@(Type|Re*|Header):*"
#+ show all sets headers, but suppress all but name and memsize entry,
#+ calculate the total memory size of all sets.
#
# $0 -t -Tm -Xh "!(Size*|Type):*" -Ts -Co
# + List all sets headers, but suppress all but name, type and memsize entry,
# + count amount of sets, calculate total memory usage, colorize the output.
#
# $0 -c -t -Cs -Ts -Xh "@(Size*|Re*|Header):*" -Ht "!(bitmap:*)"
#+ find all sets not of any bitmap type, count their members sum,
#+ display only the 'Type' header,
#+ count amount of matching and traversed sets.
#
# $0 -a -Xh "@(@(H|R|M)e*):*"  - show all info of all sets,
#+ but suppress Header, References, Revision and Member header entries.
#+ (headers existing as per ipset 6.x -> tested version).
#
# $0 -Co -c -Ts -Tm    - show all set names, count their members,
# + count total amount of sets, show total memory usage of all sets,
# + colorize the output
#
# $0 -m -r -To 0       - show members of all sets, try to resolve hosts,
# set the timeout to 0 (effectivly disabling it).
#
# $0 -m -Xo setA       - show members of setA,
# + but suppress displaying of the elements options.
#
# $0 -m -Oi packets:0
# + show members of all sets which have a packet count of 0.
#
# $0 -m -Oi "packets:>100" -Oi "bytes:>1024"
# + show members of all sets which have a
# + packet count greater than 100 and a byte count greater than 1024.
#
# $0 -m -Oi "skbmark:>0x123/0XFF" -Oi skbprio:\>=2:<=3 -Oi skbqueue:\!1
# + show members of all sets which have the following member options set:
# + skbmark greater than 0x123/0xFF, skbprio major greater or equal to 2
# + and minor lower or equal to 3, skbqueue not of value 1.
#
# $0 -n -Ca "foo*"
# + show only set names matching the glob "foo*" and enable all counters.
#
# $0 -Hi "markmask:>=0x0000beef" -Hi timeout:\!10000`
# + show only sets with the header 'Header' fields containing a markmask
# + greater or equal to 0x0000beef and a timeout which is not 10000.
#
# $0 - -d $'\n'  - enter interactive mode, globally set delim to newline.
# $0 - -G  - enter interactive mode, show generated command line.
# $0 - >/tmp/data  - enter interactive mode and redirect the output to a file.
# -----------------------------------------------------------------

# -----------------------------------------------------------------
# Modify here
# -----------------------------------------------------------------

# modify your PATH variable
# by default the path is only set if the PATH variable is not already set in the environment
# PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
#: ${PATH:=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin}

# path to ipset.
# if unset, ipset_list first tries to find ipset in path.
# on failure it next tries the default `/sbin/ipset'.
# variable can be either:
# - empty (automatic retrieval if in PATH)
# - ipset (name of the executable)
# - the full path to ipset
#ipset="/sbin/ipset"
#ipset=ipset
# find in path if not declared in parent environment
#: ${ipset:=$(command -v ipset)}

# default delimiter character for set members (elements).
# defaults to whitespace if unset.
# use delim=$'\n' to use the ipset default newline as delimiter.
#delim=" "

# default read timeout (for reading sets - esp. with the -r switch).
# the command line option -To overrides this.
#set_tmout=30

# -----------------------------------------------------------------
# color settings
# -----------------------------------------------------------------
# colorize the output (bool 0/1). default 0.
#colorize=0

# path to cl (to colorize the output).
# http://sourceforge.net/projects/colorize-shell/ or
# https://github.com/AllKind/cl
# variable can be either:
# - empty (automatic retrieval if in PATH)
# - cl (name of the executable)
# - the full path to cl
#cl="cl"
#cl="/usr/local/bin/cl"
# find in path if not declared in parent environment
#: ${cl:=$(command -v cl)}

# define colors
# run `cl --list' to retrieve the valid color names
#
# default foreground color
# defaults to: white
#col_fg="white"

# default background color
# defaults to: black
#col_bg="black"

# color for headers
# defaults to: cyan
#col_headers="cyan"

# color for members
# defaults to: yellow
#col_members="yellow"

# color for matches
# defaults to: red
#col_match="red"

# color for displaying of memsize
# defaults to: green
#col_memsize="green"

# color for counting of matched sets
# defaults to: magenta
#col_set_count="magenta"

# color for counting of traversed sets
# defaults to: blue
#col_set_total="blue"

# general higlighting color
# defaults to: white
#col_highlight="white"

# -----------------------------------------------------------------
# settings for interactive mdoe
# -----------------------------------------------------------------
# a dialog program is required for interactive mode
# either dialog (default), or whiptail are supported
# dialog version 1.2 or greater is required
# variable can be either:
# - empty (automatic retrieval if in PATH)
# - dialog or whiptail (name of the executable)
# - the full path to one of them
#dialog_prog="dialog"
#dialog_prog="/usr/bin/dialog"
# find in path if not declared in parent environment
#: ${dialog_prog:=$(command -v dialog)}
#: ${dialog_prog:=$(command -v whiptail)}

# tput binary - optional for interactive mode
# variable can be either:
# - empty (automatic retrieval if in PATH)
# - tput (name of the executable)
# - the full path to tput
#tput=tput
#tput="/usr/bin/tput"
# find in path if not declared in parent environment
: ${tput:=$(command -v tput)}

# applies to the three window measure variables below:
# if `0' and the `tput' program is available adjustment is done autmatically.
# if tput is not present, a value of `0' should give good results.
# otherwise set it to your desired value (integer),
# with the downside of fixed size.

# window height for interactive mode
#w_height=0

# window with for interactive mode
#w_with=0

# list height for interactive mode
#l_height=0

# the timeout of the result screen in interactive mode, before
# returning to the main dialog window (integer). default 9999999999.
#active_tmout=

# -----------------------------------------------------------------
# config file
# -----------------------------------------------------------------

# all the above variables can be loaded from a configuration file
# overwritting the values defined above.
config_file="/etc/default/ipset_list.conf"

# -----------------------------------------------------------------
# DO NOT MODIFY ANYTHING BEYOND THIS LINE!
# -----------------------------------------------------------------


# bash check
if [ -z "$BASH" ]; then
	printf "\`BASH' variable is not available. Not running bash?\n" >&2
	exit 1
fi

# shell settings
shopt -s extglob
set -f
set +o posix
set +u

# variables
export LC_ALL=C
readonly version=3.4
readonly me="${0//*\//}"
readonly oIFS="$IFS"
declare ips_version="" str_search="" str_xclude="" opt
declare -i member_count=match_count=do_count=show_count=calc_mem=count_sets=sets_total=0
declare -i show_all=show_members=headers_only=names_only=isolate=0
declare -i match_on_header=glob_search=regex_search=opt_int_search=test_element=0
declare -i exclude_header=glob_xclude_element=regex_xclude_element=exclude_set=xclude_member_opts=0
declare -i i=x=y=idx=0
declare -i builtin_mc=-1 # member sum - if builtin since ipset v.6.25
declare -i iactive=0 # en/disable interactive mode
declare -i iactive_err=0 # remember error state in interactive mode
declare -i generate_cmdline=global_gen_cmd=0 # generate command line in iactive mode
declare -ir default_set_tmout=30
declare -r default_delim=" "
declare global_delim="${delim:=$default_delim}"
declare -i global_colorize=${colorize:=0} global_tmout="${set_tmout:=$default_set_tmout}"
declare -a arr_hsearch=() arr_hsearch_int=() arr_hsearch_xint=() arr_match_on_msum=() arr_opt_int_search=()
declare -a arr_hxclude=() arr_sxclude=() arr_par=() all_sets=() arr_cmdline=() arr_old_select=() arr_tmp=()
declare -a arr_test_elem=()

# declare standard PATH, if not already defined in environment
: ${PATH:=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin}

# simple trap
trap "echo trap on signal activated - exiting; enable exit; exit 111" HUP INT QUIT STOP TERM

# -----------------------------------------------------------------
# functions
# -----------------------------------------------------------------

pm() { # print message
printf "$*\n"
}

pe() { # print error
printf "$*\n" >&2
}

ex_miss_optarg() { # missing option argument
pe "$2 of option \`$1' is missing"
exit 2
}

ex_err() { # exit on error
if ((iactive > 1)); then
	dia_mbox "ERROR: $*"
else
	pe "$*"
	exit 1
fi
}

is_int() { # test if arg is int
[[ $1 = +([[:digit:]]) ]]
}

is_digit_or_xigit() { # test if arg is int or 0[xX]xdigit
[[ $1 = @(+([[:digit:]])|0[xX]+([[:xdigit:]])) ]]
}

is_compare_str() { # test if arg is a compare string
[[ $1 = ?(\!|<|>|<=|>=)@(+([[:digit:]])|0[x|X]+([[:xdigit:]])) ]]
}

is_compare_str_complex() { # test if arg is a complex compare string
[[ $1 = ?(\!|<|>|<=|>=)@(+([[:digit:]])|0@(x|X)+([[:xdigit:]])?(/0@(x|X)+([[:xdigit:]]))|+([[:xdigit:]]):?(\!|<|>|<=|>=)+([[:xdigit:]])) ]]
}

test_regex() { # check if a regex expression is valid
[[ x =~ $1 ]]
if (($? == 2)); then
	return 1
fi
return 0
}

add_search_to_member_cache() { # cache set members
if ((show_members || show_all || isolate)); then
	arr_mcache[i++]="$REPLY"
fi
}

arith_elem_opt_search() { # -Oi parameter
local str_opt_val str_val2 str_op2 str_cg='?(\!|<|>|<=|>=)' str_xdig='0[xX]+([[:xdigit:]])'
found_member_opt=0
for y in ${!arr_opt_int_search[@]}; do
	str_val="${arr_opt_int_search[y]#*:}"
	if [[ $str_val = ${str_cg}@(+([[:digit:]])|$str_xdig) ]]; then # i.e. timeout or skbqueue
		str_op="${str_val//[![:punct:]]}"
		str_val="${str_val//[=\!\>\<]}"
	elif [[ $str_val  = ${str_cg}${str_xdig}/$str_xdig ]]; then # i.e. skbmark
		str_op="${str_val//[![:punct:]]}"
		str_op="${str_op//\/}"
		str_val="${str_val//[=\!\>\<]}"
	elif [[ $str_val  = ${str_cg}+([[:xdigit:]]):${str_cg}+([[:xdigit:]]) ]]; then # i.e. skbprio
		str_op="${str_val%:*}"
		str_op="${str_op%%+([[:xdigit:]])}"
		str_op2="${str_val#*:}"
		str_op2="${str_op2%%+([[:xdigit:]])}"
		str_val="${str_val##+([[:punct:]])}"
		str_val2="${str_val#*:}"
		str_val2="${str_val2//[[:punct:]]}"
	fi
	# compare operator defaults to `=='
	# if it's a '!' set it to '!='
	[[ ${str_op:===} = \! ]] && str_op='!='
	[[ ${str_op2:===} = \! ]] && str_op2='!='
	set -- $REPLY
	shift
	while (($# > 1)); do # cycle through options
		if [[ $1 = ${arr_opt_int_search[y]%%:*} ]]; then str_opt_val="$2"
			if [[ $str_val = @(+([[:digit:]])|$str_xdig) && $str_opt_val = @(+([[:digit:]])|$str_xdig) ]]
			then # i.e. timeout or skbqueue
				if (( $str_opt_val $str_op $str_val )); then
					let found_member_opt+=1
				fi
				shift
			elif [[ $str_val = $str_xdig && $str_opt_val = ${str_xdig}/$str_xdig ]]
			then # i.e. skbmark
				if (( $str_opt_val $str_op $(( ${str_val%/*} & ${str_val#*/} )) )) # logicaly AND mark/mask
				then
					let found_member_opt+=1
				fi
				shift
			elif [[ $str_val = ${str_xdig}/$str_xdig && $str_opt_val = ${str_xdig}/$str_xdig ]]
			then # i.e. skbmark
				if (( $(( ${str_opt_val%/*} & ${str_opt_val#*/} )) $str_op $(( ${str_val%/*} & ${str_val#*/} )) )) # logicaly AND mark/mask
				then
					let found_member_opt+=1
				fi
				shift
			elif [[ $str_val = +([[:xdigit:]]):${str_cg}+([[:xdigit:]]) && $str_opt_val = +([[:xdigit:]]):+([[:xdigit:]]) ]]
			then # i.e. skbprio
				if (( ${str_opt_val%:*} $str_op ${str_val%:*} && ${str_opt_val#*:} $str_op2 $str_val2 )); then
					let found_member_opt+=1
				fi
				shift
			fi
		fi
		shift
	done
done
if ((opt_int_search == found_member_opt)); then
	let match_count+=1
	add_search_to_member_cache
fi
}

xclude_elem_search() { # -Xg | -Xr
if ((glob_xclude_element)); then # exclude matching members
	if [[ $REPLY = $str_xclude ]]; then
		let xclude_count+=1
		return 0
	fi
elif ((regex_xclude_element)); then # exclude matching members
	if [[ $REPLY =~ $str_xclude ]]; then
		let xclude_count+=1
		return 0
	else
		if (($? == 2)); then
			ex_err "Invalid regex pattern \`$str_xclude'."
			((iactive > 1)) && return 2
		fi
	fi
fi
return 1
}

rdia() { # run dialog program
"$dialog_prog" --title "ipset_list interactive mode" "$@" 2>&1 > /dev/tty
}

dia_ibox() { # input box
rdia --inputbox "$1" $w_height $w_with
}

dia_mbox() { # msg box
rdia --msgbox "$1" $w_height $w_with
}

dia_clist() { # checklist
if [[ $1 = --noitem ]]; then
	local str_cmd="--noitem --separate-output --checklist"
	shift
else
	local str_cmd="--separate-output --checklist"
fi
local str="$1"
shift
rdia $str_cmd "$str" $w_height $w_with $l_height "$@"
}

interactive_mode() { # interactive mode - wizard based composing of commands
iactive=2 # -ge 1 means we are in interactive mode
# some global variables need to set on each run
i=x=0
local str_tmp
local -a xopts sopts arr_opts=() setglob=() arr_iopts=()
local -a arr_cmdline=( "$me" ) # first entry in composed cmdline is always ME :-)
local -a arr_pre_opts=(
"Select_sets" "Choose sets to operate on (default all)"
"Show_header" "Show the set header (-t)"
"Show_members" "Show the set members (-m)"
"Show_all" "Show set header and members (-a)"
"Names_only" "Show only the set names (not prefixed) (-n)"
"Members_only" "Show only the set members (-i)"
"Header_search" "Match [ext]glob matching headers (-Fh)"
"Header_int_search" "Match integer valued header entries (-Fi)"
"Header_option_int" "Match integer valued header option entries (-Hi)"
"Match_memsize" "Match on size in memory (-Hs)"
"Match_references" "Match on number of references (-Hr)"
"Match_revision" "Match on revision number (-Hv)"
"Match_type" "Match on set type (-Ht)"
"Glob_search" "Match members using a [ext]glob patterni (-Fg)"
"Regex_search" "Match members using a regex pattern (-Fr)"
"Opt_int_search" "Match integer valued member options (-Oi)"
"Match_member_sum" "Match on member count (value=int) (-Mc)"
"Test_element" "Test if an element is in the set (-T)"
"Exclude_set" "Exclude sets matching a [ext]glob pattern (-Xs)"
"Exclude_header" "Suppress [ext]glob matching header entries (-Xh)"
"Glob_xclude_elem" "Exclude members matching a [ext]glob pattern (-Xg)"
"Regex_xclude_elem" "Exclude members matching a regex pattern (-Xr)"
"Exclude_elem_opt" "Suppress display of member options (-Xo)"
"Count_sets" "Count amount of matching sets (-Cs)"
"Count_members" "Calculate members and match sum (-c)"
"Calc_mem" "Calculate memory usage of all matching sets (-Tm)"
"Count_sets_total" "Count amount of traversed sets (-Ts)"
"All_counters" "Enable all counters (-Ca)"
"Colorize" "Enable colored output (-Co)"
"Delim" "Delimiter character for separating members (-d)"
"Resolve" "Resolve ip addresses in the output (slow!) (-r)"
"Sort" "Print elements sorted (if supported) (-s)"
"Generate_cmd" "Generate the $me command line (-G)"
"Timeout" "Timeout for reading sets (-To)"
)

# compose the selection.
# for default everything is turned of.
# if we have an error condition because of invalid user input,
# we recover the previously remembered selection and turn them on.
for ((i=0; i<${#arr_pre_opts[@]}; i=i+2)); do
	if ((iactive_err && ${#arr_old_select[@]})); then
		for x in ${!arr_old_select[@]}; do
			if [[ ${arr_pre_opts[i]} = ${arr_old_select[x]} ]]; then
				arr_opts[${#arr_opts[@]}]="${arr_pre_opts[i]}"
				arr_opts[${#arr_opts[@]}]="${arr_pre_opts[i+1]}"
				arr_opts[${#arr_opts[@]}]="on"
				unset arr_old_select[x]
				continue 2
			fi
		done
	fi
	arr_opts[${#arr_opts[@]}]="${arr_pre_opts[i]}"
	arr_opts[${#arr_opts[@]}]="${arr_pre_opts[i+1]}"
	arr_opts[${#arr_opts[@]}]="off"
done
iactive_err=0
arr_old_select=()

# main screen: checklist with all options
xopts=( $(dia_clist \
"Select options (multiple choice). Use SPACE key to (de)select.\n\
After you confirm with ENTER or the OK button, options will be evaluated.\n\
You will be prompted for input if an option requires this.\n\
Use the ESC key or CANCEL button to quit." "${arr_opts[@]}") )
if (($?)); then
	return 1 # user quit
fi

# remember selection - in case of invalid input we can restore the selection
for x in ${!xopts[@]}; do
	[[ ${xopts[x]} ]] || continue
	arr_old_select[${#arr_old_select[@]}]="${xopts[x]}"
done

# iterate over selected options
for ((x=0; x<=${#xopts[*]}; x++)); do
	[[ ${xopts[x]} ]] || continue
	if [[ ${xopts[x]} = Select_sets ]]; then
		if ((${#all_sets[@]} == 1)); then
			dia_mbox "There is only one set present. Automatically selecting it."
			setglob=( ${all_sets[*]} )
			continue
		fi
		sopts=( $(dia_clist \
			"Select the desired options (multiple choice)." \
			"List" "Select from list" off "Glob" "Enter a search [ext]glob" off) )
		if ((${#sopts[*]})); then
			for ((i=0; i<=${#sopts[*]}; i++)); do
				if [[ ${sopts[i]} = List ]]; then arr_tmp=()
					arr_tmp=( $(dia_clist --noitem "Choose the set(s) (multiple choice)." \
						$(printf "%s off\n" "${all_sets[@]}")) )
					if ((${#arr_tmp[@]})); then
						setglob+=( "${arr_tmp[@]}" )
					fi
				elif [[ ${sopts[i]} = Glob ]]; then
					while (($? == 0)); do
						setglob+=( $(dia_ibox "Enter one or more glob expression(s) for: ${xopts[x]}.\nCancel to quit.") )
					done
				fi
			done
		fi
	elif [[ ${xopts[x]} = Show_header ]]; then # show header only
		headers_only=1 arr_cmdline[${#arr_cmdline[@]}]="-t"
	elif [[ ${xopts[x]} = Show_members ]]; then # show members
		show_members=1 arr_cmdline[${#arr_cmdline[@]}]="-m"
	elif [[ ${xopts[x]} = Show_all ]]; then # show header and members
		show_all=1 arr_cmdline[${#arr_cmdline[@]}]="-a"
	elif [[ ${xopts[x]} = Names_only ]]; then # show only not prefixed set names
		names_only=1 arr_cmdline[${#arr_cmdline[@]}]="-n"
	elif [[ ${xopts[x]} = Members_only ]]; then # isolate members of a single set
		isolate=1 arr_cmdline[${#arr_cmdline[@]}]="-i"
	elif [[ ${xopts[x]} = Header_search ]]; then # show only sets, which contain a matching header entry
		while (($? == 0)); do
			arr_hsearch[${#arr_hsearch[@]}]=$(dia_ibox \
				"Enter one or more glob expression(s) for: ${xopts[x]}.\nExpected input: \`*:*'\nCancel to quit.")
			if (($? == 0)); then
				if ! [[ ${arr_hsearch[$(( ${#arr_hsearch[@]} - 1 ))]} = *:* ]]; then
					ex_err "Invalid format of header descriptor: \`${arr_hsearch[$(( ${#arr_hsearch[@]} - 1 ))]}'. Expecting: \`*:*'"
					iactive_err=1
					return 0
				fi
				let match_on_header+=1
				arr_cmdline[${#arr_cmdline[@]}]="-Fh"
				arr_cmdline[${#arr_cmdline[@]}]="\"${arr_hsearch[$(( ${#arr_hsearch[@]} - 1 ))]}\"" #"
			else
				((${#arr_hsearch[@]})) && unset arr_hsearch[$(( ${#arr_hsearch[@]} - 1 ))]
				break
			fi
		done
	elif [[ ${xopts[x]} = Header_int_search ]]; then # show only sets, containing a matching (int compare) header entry
		while (($? == 0)); do
			arr_hsearch_int[${#arr_hsearch_int[@]}]=$(dia_ibox \
				"Enter one or more glob expression(s) for: ${xopts[x]}.\nExpected input: \`glob:[!|<|>|<=|>=]value'\nCancel to quit.")
			if (($? == 0)); then
				if ! is_compare_str "${arr_hsearch_int[$(( ${#arr_hsearch_int[@]} - 1 ))]#*:}"; then
					ex_err "Invalid format of header descriptor: \`${arr_hsearch_int[$(( ${#arr_hsearch_int[@]} - 1 ))]}'. Expecting: \`glob:[!|<|>|<=|>=]value'"
					return 0
				fi
				let match_on_header+=1
				arr_cmdline[${#arr_cmdline[@]}]="-Fi"
				arr_cmdline[${#arr_cmdline[@]}]="\"$(printf "%q\n" ${arr_hsearch_int[$(( ${#arr_hsearch_int[@]} - 1 ))]} )\"" #"
			else
				((${#arr_hsearch_int[@]})) && unset arr_hsearch_int[$(( ${#arr_hsearch_int[@]} - 1 ))]
				break
			fi
		done
	elif [[ ${xopts[x]} = Header_option_int ]]; then
		# match on name + integer (digit & xdigit) inside of headers 'Header' flag
		while (($? == 0)); do
			arr_hsearch_xint[${#arr_hsearch_xint[@]}]=$(dia_ibox \
				"Enter one or more expression(s) for: ${xopts[x]}.\nExpected input: \`glob:[!|<|>|<=|>=]value'\nCancel to quit.")
			if (($? == 0)); then
				if ! [[ ${arr_hsearch_xint[$(( ${#arr_hsearch_xint[@]} - 1 ))]} = *:* ]]; then
					ex_err "Invalid format of headers \'Header' flag descriptor: \`${arr_hsearch_xint[$(( ${#arr_hsearch_xint[@]} - 1 ))]}'. Expecting: \`glob:[!|<|>|<=|>=]value'"
					return 0
				fi
				let match_on_header+=1
				arr_cmdline[${#arr_cmdline[@]}]="-Hi"
				arr_cmdline[${#arr_cmdline[@]}]="$(printf "%q\n" ${arr_hsearch_xint[$(( ${#arr_hsearch_xint[@]} - 1 ))]} )"
			else
				((${#arr_hsearch_xint[@]})) && unset arr_hsearch_xint[$(( ${#arr_hsearch_xint[@]} - 1 ))]
				break
			fi
		done
	elif [[ ${xopts[x]} = Match_memsize ]]; then # shortcut for -Fi "Size in Memory:..."
		str_tmp=$(dia_ibox "Enter compare expression for: ${xopts[x]}.\nExpected input: \`[!|<|>|<=|>=]value'")
		if (($? == 0)); then
			if ! is_compare_str "$str_tmp"; then
				ex_err "Invalid format of references header descriptor: \`$str_tmp'. Expecting: \`[!|<|>|<=|>=]value'"
				return 0
			fi
			let match_on_header+=1
			arr_hsearch_int[${#arr_hsearch_int[@]}]="Size in memory:$str_tmp"
			arr_cmdline[${#arr_cmdline[@]}]="-Hs"
			arr_cmdline[${#arr_cmdline[@]}]="$(printf "%q\n" $str_tmp)"
		fi
	elif [[ ${xopts[x]} = Match_references ]]; then # shortcut for -Fi References:...
		str_tmp=$(dia_ibox "Enter compare expression for: ${xopts[x]}.\nExpected input: \`[!|<|>|<=|>=]value'")
		if (($? == 0)); then
			if ! is_compare_str "$str_tmp"; then
				ex_err "Invalid format of references header descriptor: \`$str_tmp'. Expecting: \`[!|<|>|<=|>=]value'"
				return 0
			fi
			let match_on_header+=1
			arr_hsearch_int[${#arr_hsearch_int[@]}]="References:$str_tmp"
			arr_cmdline[${#arr_cmdline[@]}]="-Hr"
			arr_cmdline[${#arr_cmdline[@]}]="$(printf "%q\n" $str_tmp)"
		fi
	elif [[ ${xopts[x]} = Match_revision ]]; then # shortcut for -Fi Revision:...
		str_tmp=$(dia_ibox "Enter compare expression for: ${xopts[x]}.\nExpected input: \`[!|<|>|<=|>=]value'")
		if (($? == 0)); then
			if ! is_compare_str "$str_tmp"; then
				ex_err "Invalid format of references header descriptor: \`$str_tmp'. Expecting: \`[!|<|>|<=|>=]value'"
				return 0
			fi
			let match_on_header+=1
			arr_hsearch_int[${#arr_hsearch_int[@]}]="Revision:$str_tmp"
			arr_cmdline[${#arr_cmdline[@]}]="-Hv"
			arr_cmdline[${#arr_cmdline[@]}]="$(printf "%q\n" $str_tmp)"
		fi
	elif [[ ${xopts[x]} = Match_type ]]; then # shortcut for -Fh Type:x:y
		str_tmp=$(dia_ibox "Enter glob expression for: ${xopts[x]}.\nExpected input: \`*:*'")
		if (($? == 0)); then
			if ! [[ $str_tmp = *:* ]]; then
				ex_err "Invalid format of set type descriptor: \`$str_tmp'. Expecting: \`*:*'."
				return 0
			fi
			let match_on_header+=1
			arr_hsearch[${#arr_hsearch[@]}]="Type:$str_tmp"
			arr_cmdline[${#arr_cmdline[@]}]="-Ht"
			arr_cmdline[${#arr_cmdline[@]}]="\"$str_tmp\"" #"
		fi
	elif [[ ${xopts[x]} = Glob_search ]]; then # glob match members
		str_search=( $(dia_ibox "Enter the glob expression for: ${xopts[x]}") )
		if (($? == 0)); then
			glob_search=1
			arr_cmdline[${#arr_cmdline[@]}]="-Fg"
			arr_cmdline[${#arr_cmdline[@]}]="\"$str_search\"" #"
		fi
	elif [[ ${xopts[x]} = Regex_search ]]; then # regex match members
		str_search=( $(dia_ibox "Enter the regex expression for: ${xopts[x]}") )
		if (($? == 0)); then
			if ! test_regex "$str_search"; then
				ex_err "Invalid regex pattern \`$str_search'."
				return 0
			fi
			regex_search=1
			arr_cmdline[${#arr_cmdline[@]}]="-Fr"
			arr_cmdline[${#arr_cmdline[@]}]="\"$str_search\"" #"
		fi
	elif [[ ${xopts[x]} = Opt_int_search ]]; then # match values of member options
		while (($? == 0)); do
			arr_opt_int_search[${#arr_opt_int_search[@]}]=$(dia_ibox \
				"Enter one or more expression(s) for: ${xopts[x]}.\nExpected input: \`glob:[!|<|>|<=|>=]value'\nvalue = int | 0xhex[/0xhex] | hex:[!|<|>|<=|>=]hex\nCancel to quit.")
			if (($? == 0)); then
				if ! ( [[ ${arr_opt_int_search[$(( ${#arr_opt_int_search[@]} - 1 ))]} = *:* ]] && is_compare_str_complex "${arr_opt_int_search[$(( ${#arr_opt_int_search[@]} - 1 ))]#*:}" )
				then
					ex_err "Invalid format of member options expression: \`${arr_opt_int_search[$(( ${#arr_opt_int_search[@]} - 1 ))]}'. Expecting: \`glob:[!|<|>|<=|>=]value'"
					return 0
				fi
				let opt_int_search+=1
				arr_cmdline[${#arr_cmdline[@]}]="-Oi"
				arr_cmdline[${#arr_cmdline[@]}]="$(printf "%q\n" ${arr_opt_int_search[$(( ${#arr_opt_int_search[@]} - 1 ))]} )"
			else
				((${#arr_opt_int_search[@]})) && unset arr_opt_int_search[$(( ${#arr_opt_int_search[@]} - 1 ))]
				break
			fi
		done
	elif [[ ${xopts[x]} = Match_member_sum ]]; then # match on total amount of members
		while (($? == 0)); do
			arr_match_on_msum[${#arr_match_on_msum[@]}]=$(dia_ibox \
				"Enter one or more compare expression(s) for: ${xopts[x]}.\nExpected input: \`[!|<|>|<=|>=]value'\nCancel to quit.")
			if (($? == 0)); then
				if ! is_compare_str "${arr_match_on_msum[$(( ${#arr_match_on_msum[@]} - 1 ))]}"; then
					ex_err "Invalid format of match on member count value: \`${arr_match_on_msum[$(( ${#arr_match_on_msum[@]} - 1 ))]}'. Expecting: \`[!|<|>|<=|>=]value'"
					return 0
				fi
				do_count=1
				arr_cmdline[${#arr_cmdline[@]}]="-Mc"
				arr_cmdline[${#arr_cmdline[@]}]="$(printf "%q\n" ${arr_match_on_msum[$(( ${#arr_match_on_msum[@]} - 1 ))]} )"
			else
				((${#arr_match_on_msum[@]})) && unset arr_match_on_msum[$(( ${#arr_match_on_msum[@]} - 1 ))]
				break
			fi
		done
	elif [[ ${xopts[x]} = Exclude_set ]]; then # exclude certain sets
		while (($? == 0)); do
			arr_sxclude[${#arr_sxclude[@]}]=$(dia_ibox \
				"Enter one or more glob expression(s) for: ${xopts[x]}.\nCancel to quit.")
			if (($? == 0)); then
				exclude_set=1
				arr_cmdline[${#arr_cmdline[@]}]="-Xs"
				arr_cmdline[${#arr_cmdline[@]}]="\"${arr_sxclude[$(( ${#arr_sxclude[@]} - 1 ))]}\"" #"
			else
				((${#arr_sxclude[@]})) && unset arr_sxclude[$(( ${#arr_sxclude[@]} - 1 ))]
				break
			fi
		done
	elif [[ ${xopts[x]} = Test_element ]]; then # test for existence of element
		while (($? == 0)); do
			arr_test_elem[${#arr_test_elem[@]}]=$(dia_ibox \
				"Enter one or more elemnts for: ${xopts[x]}.\nCancel to quit.")
			if (($? == 0)); then
				let test_element+=1
				arr_cmdline[${#arr_cmdline[@]}]="-T"
				arr_cmdline[${#arr_cmdline[@]}]="\"${arr_test_elem[$(( ${#arr_test_elem[@]} - 1 ))]}\"" #"
			else
				((${#arr_test_elem[@]})) && unset arr_test_elem[$(( ${#arr_test_elem[@]} - 1 ))]
				break
			fi
		done
	elif [[ ${xopts[x]} = Exclude_header ]]; then # don't show certain headers
		while (($? == 0)); do
			arr_hxclude[${#arr_hxclude[@]}]=$(dia_ibox \
				"Enter one or more glob expression(s) for: ${xopts[x]}.\nExpected input: \`*:*'.\nCancel to quit.")
			if (($? == 0)); then
				if ! [[ ${arr_hxclude[$(( ${#arr_hxclude[@]} - 1 ))]} = *:* ]]; then
					ex_err "Invalid format of header descriptor: \`${arr_hxclude[$(( ${#arr_hxclude[@]} - 1 ))]}'. Expecting: \`*:*'"
					return 0
				fi
				exclude_header=1
				arr_cmdline[${#arr_cmdline[@]}]="-Xh"
				arr_cmdline[${#arr_cmdline[@]}]="\"${arr_hxclude[$(( ${#arr_hxclude[@]} - 1 ))]}\"" #"
			else
				((${#arr_hxclude[@]})) && unset arr_hxclude[$(( ${#arr_hxclude[@]} - 1 ))]
				break
			fi
		done
	elif [[ ${xopts[x]} = Glob_xclude_elem ]]; then # exclude members matching a glob
		str_xclude=( $(dia_ibox "Enter the glob expression for: ${xopts[x]}") )
		if (($? == 0)); then
			glob_xclude_element=1
			arr_cmdline[${#arr_cmdline[@]}]="-Xg"
			arr_cmdline[${#arr_cmdline[@]}]="\"$str_xclude\"" #"
		fi
	elif [[ ${xopts[x]} = Regex_xclude_elem ]]; then # exclude members matching a regex pattern
		str_xclude=( $(dia_ibox "Enter the regex expression for: ${xopts[x]}") )
		if (($? == 0)); then
			if ! test_regex "$str_xclude"; then
				ex_err "Invalid regex pattern \`$str_xclude'."
				return 0
			fi
			regex_xclude_element=1
			arr_cmdline[${#arr_cmdline[@]}]="-Xr"
			arr_cmdline[${#arr_cmdline[@]}]="\"$str_xclude\"" #"
		fi
	elif [[ ${xopts[x]} = Exclude_elem_opt ]]; then # suppress display of members options
		xclude_member_opts=1 arr_cmdline[${#arr_cmdline[@]}]="-Xo"
	elif [[ ${xopts[x]} = Count_sets ]]; then # count matching sets
		count_sets=1 arr_cmdline[${#arr_cmdline[@]}]="-Cs"
	elif [[ ${xopts[x]} = Count_members ]]; then # count members and member matches
		show_count=1 arr_cmdline[${#arr_cmdline[@]}]="-c"
	elif [[ ${xopts[x]} = Calc_mem ]]; then # calculate total mem usage
		calc_mem=1 arr_cmdline[${#arr_cmdline[@]}]="-Tm"
	elif [[ ${xopts[x]} = Count_sets_total ]]; then # count amount of traversed sets
		sets_total=1 arr_cmdline[${#arr_cmdline[@]}]="-Ts"
	elif [[ ${xopts[x]} = All_counters ]]; then # enable all counters
		show_count=1 count_sets=1 calc_mem=1 sets_total=1
		arr_cmdline[${#arr_cmdline[@]}]="-Ca"
	elif [[ ${xopts[x]} = Colorize ]]; then # colorize output
		colorize=1 arr_cmdline[${#arr_cmdline[@]}]="-Co"
	elif [[ ${xopts[x]} = Delim ]]; then # delimiter character for separating member entries
		delim=( $(dia_ibox \
			"Enter the new delimiter character.\nPersistent until you reset it.\n\$'string' type escapes are not supported in interactive mode.") )
		if ((${#delim} > 1)); then
			ex_err "Only one character is allowed as delim"
			return 0
		fi
		arr_cmdline[${#arr_cmdline[@]}]="-d"
		arr_cmdline[${#arr_cmdline[@]}]="\"$delim\"" #"
	elif [[ ${xopts[x]} = Resolve ]]; then str_tmp=0 # resolve members
		if ((${#arr_par[@]})); then
			for i in ${!arr_par[@]}; do
				if [[ ${arr_par[i]} = -r ]]; then
					str_tmp=1
				fi
			done
		fi
		if ! ((str_tmp)); then
			arr_par[${#arr_par[@]}]="-r"
		fi
	elif [[ ${xopts[x]} = Sort ]]; then str_tmp=0 # sort members
		if ((${#arr_par[@]})); then
			for i in ${!arr_par[@]}; do
				if [[ ${arr_par[i]} = -s ]]; then
					str_tmp=1
				fi
			done
		fi
		if ! ((str_tmp)); then
			arr_par[${#arr_par[@]}]="-s"
		fi
	elif [[ ${xopts[x]} = Generate_cmd ]]; then # generate ipset_list cmd-line
		generate_cmdline=1
	elif [[ ${xopts[x]} = Timeout ]]; then # timeout for reading sets
		set_tmout=( $(dia_ibox "Enter the timeout value (integer): ${xopts[x]}") )
		if (($? == 0)); then
			if ! is_int "$set_tmout"; then
				ex_err "Timeout value \`$set_tmout' is not an integer."
				return 0
			fi
			arr_cmdline[${#arr_cmdline[@]}]="-To"
			arr_cmdline[${#arr_cmdline[@]}]="$set_tmout"
		fi
	fi
done

# run main with set glob as optional option
main "${setglob[@]}"
pm
if ((generate_cmdline)); then # generate the ipset_list cmd-line
	if ((${#arr_par[@]})); then
		arr_cmdline[${#arr_cmdline[@]}]="${arr_par[*]}"
	fi
	if ((${#setglob[@]})); then
		for i in ${!setglob[@]}; do
			arr_cmdline[${#arr_cmdline[@]}]="\"${setglob[i]}\"" #"
		done
	fi
	pm "Composed command line:"
	printf "    %s\n" "${arr_cmdline[*]}"
	pm
fi
read -t ${iactive_tmout:-9999999999} -N 1 -p " Press \`ENTER' to continue, or \`ESC' to return to the shell."
if [[ $REPLY = $'\E' ]]; then
	pm # avoid moving the shell prompt
	return 1
fi
}

main() { # well yes - what to say, it's main() :-)
local str_name str_set str_val str_op
local -i in_header=found_set=found_member_opt=found_hxclude=found_sxclude=test_succeed=0
local -i xclude_count=mem_total=mem_tmp=set_count=sets_sum=0
i=0 x=0 idx=0
arr_sets=() arr_hcache=() arr_mcache=() arr_tmp=()

# option logic
if ((names_only)); then
	if ((headers_only||show_members||show_all||isolate||\
		glob_xclude_element||regex_xclude_element||xclude_member_opts))
   	then
		ex_err "Option -n does not allow this combination of options"
		((iactive > 1)) && return 0
	fi
fi
if ((headers_only)); then
	if ((show_members || show_all || isolate)); then
		ex_err "Options -t and -a|-i|-m are mutually exclusive"
		((iactive > 1)) && return 0
	fi
fi
if ((headers_only)); then
	if ((xclude_member_opts||glob_xclude_element||regex_xclude_element)); then
		ex_err "Options -t and -Xg|-Xr|-Xo are mutually exclusive"
		((iactive > 1)) && return 0
	fi
fi
if ((isolate)); then
	if ((show_count||show_all||calc_mem||count_sets||sets_total||exclude_set)); then
		ex_err "Options -i and -a|-c|-Ca|-Cs|-Tm|-Ts|-Xs are mutually exclusive"
		((iactive > 1)) && return 0
	fi
	if ((match_on_header)); then
		ex_err "Option -i does not allow matching on header entries"
		((iactive > 1)) && return 0
	fi
fi
if ((glob_search || regex_search)); then
	if ((glob_search && regex_search)); then
		ex_err "Options -Fg and -Fr are mutually exclusive"
		((iactive > 1)) && return 0
	fi
fi
if ((exclude_header)); then
	if ! ((headers_only || show_all)); then
		ex_err "Option -Xh requires -a or -t"
		((iactive > 1)) && return 0
	fi
fi
if ((glob_xclude_element || regex_xclude_element)); then
	if ! ((show_members || show_all || isolate)); then
		ex_err "Options -Xg|-Xr require any of -a|-i|-m"
		((iactive > 1)) && return 0
	fi
fi
if ((colorize)); then
	while :; do
		[[ $cl ]] && command -v "$cl" &>/dev/null && break
		[[ -x ${cl:-$(command -v cl)} ]] && cl="$(command -v cl)" && break
		[[ -x ${cl:=/usr/local/bin/cl} ]] && break
		if ((iactive > 1)); then
			ex_err "Cannot colorize the output. cl program \`$cl' does not exist, or is not executable. \
If you do not have the program, you can download it from: \
http://sourceforge.net/projects/colorize-shell/ or \
https://github.com/AllKind/cl"
			return 0
		else
			printf "\nCannot colorize the output.\ncl program \`%s' does not exist, or is not executable.\ncheck \`cl' variable.\n\n" "$cl" >&2
			printf "If you do not have the program, you can download it from:\n" >&2
			printf "%s\n" "http://sourceforge.net/projects/colorize-shell/" "https://github.com/AllKind/cl" >&2
			printf "\n"
			exit 1
		fi
	done
	# set color defaults if unset
	: ${col_fg:=white}
	: ${col_bg:=black}
	: ${col_headers:=cyan}
	: ${col_members:=yellow}
	: ${col_match:=red}
	: ${col_memsize:=green}
	: ${col_set_count:=magenta}
	: ${col_set_total:=blue}
	: ${col_highlight:=white}

	# check if color defines are valid
	for opt in col_fg col_bg col_headers col_members col_match col_memsize \
	   	col_set_count col_set_total col_highlight
	do
		if ! ("$cl" "${!opt}"); then
			ex_err "Variable \`$opt' has an invalid color value: \`${!opt}'"
			return 1
		fi
	done
	[[ -t 1 ]] || colorize=0 # output is not a terminal
fi

if [[ $1 ]]; then # there are remaining arg(s)
	for opt; do found_set=0 # check if the sets exist
		for idx in ${!all_sets[@]}; do
			if [[ ${all_sets[idx]} = $opt ]]; then found_set=1
				# match could be a glob, thus multiple matches possible
				# save to temp array
				arr_tmp[${#arr_tmp[@]}]="${all_sets[idx]}"
			fi
		done
		if ! ((found_set)); then
			ex_err "\`$opt' is not a valid option nor an existing set name"
			((iactive > 1)) && return 0
		fi
	done
	if ((isolate)); then
		if (($# != 1)); then
			ex_err "Option -i is only valid for a single set"
			((iactive > 1)) && return 0
		fi
	fi
	arr_sets=("${arr_tmp[@]}") # reassign matched sets
	if ((isolate && ${#arr_sets[@]} > 1)); then
		ex_err "Option -i is only valid for a single set"
		((iactive > 1)) && return 0
	fi
else
	if ((isolate)); then
		ex_err "Option -i is only valid for a single set"
		((iactive > 1)) && return 0
	fi
	arr_sets=( "${all_sets[@]}" )
fi

# read sets
for idx in "${!arr_sets[@]}"; do str_set="${arr_sets[idx]}"
	found_set=0 test_succeed=0 arr_hcache=() arr_mcache=()
	if ((test_element)); then # test for existence of members
		for y in ${!arr_test_elem[@]}; do
			if "$ipset" test "$str_set" "${arr_test_elem[y]}" &>/dev/null; then
				let test_succeed+=1
			fi
		done
		test_succeed=$((test_succeed < test_element ? 0 : test_succeed)) # not all tests succeeded
	fi
	while read -r -t ${set_tmout:=$default_set_tmout} || {
		(($? > 128)) && pe "Timeout reached or signal received, while reading set \`$str_set'." && continue 2;
   	}; do
		case "$REPLY" in
			"") : ;;
			Name:*) # header opened (set found)
				if ((in_header)); then
					ex_err "Unexpected entry: \`$REPLY' - header not closed?"
				fi
				let sets_sum+=1
				if ((exclude_set)); then # don't show certain sets
					for y in ${!arr_sxclude[@]}; do
						if [[ $str_set = ${arr_sxclude[y]} ]]; then
							let found_sxclude+=1
							continue 3 # don't unset, as user could list sets multiple times
						fi
					done
				fi
				found_header=0 member_count=0 match_count=0 xclude_count=0 mem_tmp=0 builtin_mc=-1 i=0 x=0
				if ((test_element != test_succeed)); then
					break # not all tests succeeded, nothing more to do, we can now safely quit
				fi
				in_header=1 found_set=1
				if ! ((isolate)); then # if showing members only, continue without saving any header data
					if ((names_only)); then
						if ((colorize)); then
							arr_hcache[x++]="$("$cl" bold $col_headers)${REPLY#*:+([[:blank:]])}$("$cl" normal $col_fg $col_bg)"
						else
							arr_hcache[x++]="${REPLY#*:+([[:blank:]])}"
						fi
					elif ! ((headers_only||show_members||show_all||show_count||match_on_header||do_count||calc_mem||glob_search||regex_search||opt_int_search))
				   	then
						in_header=0
						if ((colorize)); then
							arr_hcache[x++]="$("$cl" bold $col_headers)${REPLY}$("$cl" normal $col_fg $col_bg)"
						else
							arr_hcache[x++]="$REPLY"
						fi
						break # nothing to show but the names
					else
						if ((colorize)); then
							arr_hcache[x++]=$'\n'"$("$cl" bold $col_headers)${REPLY}$("$cl" normal $col_fg $col_bg)"
						else
							arr_hcache[x++]=$'\n'"$REPLY"
						fi
					fi
				fi
			;;
			Members:*) # closes header (if not `ipset -t')
				if ! ((in_header)); then
					pe "Unexpected entry: \`$REPLY' - header not opened?"
					exit 1
				fi
				in_header=0 found_hxclude=0
				if ((match_on_header)); then
					if ((found_header != match_on_header)); then found_set=0
						break # set does not contain wanted header
					fi
				fi
				if ((exclude_header)); then # don't show certain headers
					for y in ${!arr_hxclude[@]}; do
						if [[ ${REPLY%%:*} = ${arr_hxclude[y]%%:*} && ${REPLY#*: } = ${arr_hxclude[y]#*:} ]]
						then found_hxclude=1
							break
						fi
					done
				fi
				if ((show_all && ! found_hxclude)); then
					if ((colorize)); then
						arr_hcache[x++]="$("$cl" bold $col_headers)${REPLY}$("$cl" normal $col_fg $col_bg)"
					else
						arr_hcache[x++]="$REPLY"
					fi
				fi
			;;
			*) # either in-header, or member entry
				if ! ((found_set)); then
					pe "No set opened by \`Name:'. Unexpected entry: \`$REPLY'."
					exit 1
				fi
				if ((in_header)); then # we should be in the header
					if [[ $REPLY = "Number of entries:"+([[:blank:]])+([[:digit:]]) ]]; then
						builtin_mc=${REPLY#*:+([[:blank:]])}
					fi
					if ((match_on_header && found_header < match_on_header)); then # match on an header entry
						for y in ${!arr_hsearch[@]}; do # string compare
							if [[ ${REPLY%%:*} = ${arr_hsearch[y]%%:*} && ${REPLY#*: } = ${arr_hsearch[y]#*:} ]]
							then let found_header+=1
							fi
						done
						for y in ${!arr_hsearch_int[@]}; do # int compare
							if [[ ${REPLY%%:*} = ${arr_hsearch_int[y]%%:*} ]]; then # header name matches
								if ! is_int "${REPLY#*: }"; then
									pe "Header value \`${REPLY#*: }' is not an integer."
									exit 1
								fi
								str_val="${arr_hsearch_int[y]#*:}"
								str_op="${str_val//[[:digit:]]}" # compare operator defaults to `=='
								[[ ${str_op:===} = \! ]] && str_op='!='
								if ((${REPLY#*: } $str_op ${str_val//[[:punct:]]})); then
									let found_header+=1
								fi
							fi
						done
						# search and arithmetic compare values of the headers 'Header' flag
						if ((${#arr_hsearch_xint[@]})) && [[ ${REPLY%%:*} = Header ]]; then
							set -- ${REPLY#*:}
							while (($#)); do
								if is_digit_or_xigit "$1"; then
									shift
									continue
								fi
								for y in ${!arr_hsearch_xint[@]}; do
									str_name="${arr_hsearch_xint[y]%%:*}"
									str_val="${arr_hsearch_xint[y]#*:}"
									if [[ $str_val = ??0[xX]+([[:xdigit:]]) ]]; then
										str_op="${str_val%0[xX]*}"
									elif [[ $str_val = ??+([[:digit:]]) ]]; then
										str_op="${str_val//[[:digit:]]}"
									fi
									str_val="${str_val#"${str_op}"}"
									[[ ${str_op:===} = \! ]] && str_op='!='
									if [[ $1 = $str_name ]]; then
										if is_digit_or_xigit "$2"; then
											if (($2 $str_op $str_val)); then
												let found_header+=1
												shift
												break
											fi
										fi
									fi
								done
								shift
							done
						fi
					fi
					if ((calc_mem)); then
						if [[ ${REPLY%%:*} = "Size in memory" ]]; then
							if ! is_int "${REPLY#*: }"; then
								pe "Header value \`${REPLY#*: }' is not an integer."
								exit 1
							fi
							# save to temp, in case we throw away the set, if it doesn't match other criteria
							mem_tmp=${REPLY#*: }
						fi
					fi
					if ((headers_only || show_all)); then found_hxclude=0
						if ((exclude_header)); then # don't show certain headers
							for y in ${!arr_hxclude[@]}; do
								if [[ ${REPLY%%:*} = ${arr_hxclude[y]%%:*} && ${REPLY#*: } = ${arr_hxclude[y]#*:} ]]
								then found_hxclude=1
									break
								fi
							done
						fi
						if ! ((found_hxclude)); then
							arr_hcache[x++]="$REPLY"
						fi
					fi
				else # this should be a member entry
					if ((show_members || show_all || isolate || glob_search || regex_search || opt_int_search)); then
						if ((glob_search)); then # show sets with glob pattern matching members
							if ! xclude_elem_search; then
								(($? == 2 && iactive > 1)) && return 0
								if [[ $REPLY = $str_search ]]; then
									if ((opt_int_search)); then # glob matches, -Oi is also requested
										arith_elem_opt_search
									else
										let match_count+=1
										add_search_to_member_cache
									fi
								fi
							fi
						elif ((regex_search)); then # show sets with regex pattern matching members
							if ! xclude_elem_search; then
								(($? == 2 && iactive > 1)) && return 0
								if [[ $REPLY =~ $str_search ]]; then
									if ((opt_int_search)); then # regex matches, -Oi is also requested
										arith_elem_opt_search
									else
										let match_count+=1
										add_search_to_member_cache
									fi
								else
									if (($? == 2)); then
										ex_err "Invalid regex pattern \`$str_search."
										((iactive > 1)) && return 0
									fi
								fi
							fi
						elif ((opt_int_search)); then # show sets with matching member options
							if ! xclude_elem_search; then
								(($? == 2 && iactive > 1)) && return 0
								arith_elem_opt_search
							fi
						else
							if ((glob_xclude_element)); then # exclude matching members
								if ! [[ $REPLY = $str_xclude ]]; then
									add_search_to_member_cache
								else let xclude_count+=1
								fi
							elif ((regex_xclude_element)); then # exclude matching members
								if [[ $REPLY =~ $str_xclude ]]; then
									let xclude_count+=1
								else
									if (($? == 2)); then
										ex_err "Invalid regex pattern \`$str_xclude."
										((iactive > 1)) && return 0
									fi
									add_search_to_member_cache
								fi
							else
								arr_mcache[i++]="$REPLY"
							fi
						fi
					else # nothing to show or search for, do we need to count members?
						if ! ((show_count || do_count)); then
							break # nothing more to do for this set
						elif ((builtin_mc != -1)); then # we need to count, but we can use the builtin counter
							member_count=$builtin_mc
							break
						fi
					fi
					# finally just count. not using builtin counter, would require check -> not worth it
					let member_count+=1
				fi
		esac
	done < <("$ipset" list "$str_set" "${arr_par[@]}")
	if ((found_set)); then # print gathered information
		if ((glob_search || regex_search || opt_int_search)) && ((match_count == 0)); then
			continue # glob, regex or option-integer search didn't match
		fi
		if ((${#arr_match_on_msum[@]} > 0)); then # match on member sum (do_count=1)
			for i in ${!arr_match_on_msum[@]}; do
				str_op="${arr_match_on_msum[i]//[[:digit:]]}"
				[[ ${str_op:===} = \! ]] && str_op='!='
				if ! (($member_count $str_op ${arr_match_on_msum[i]//[[:punct:]]})); then
					continue 2 # does not match
				fi
			done
		fi
		let set_count+=1 # count amount of matching sets
		if ((calc_mem)); then
			let mem_total+=$mem_tmp
		fi
		if ((${#arr_hcache[@]})); then # print header
			if ((colorize)); then
				printf "$("$cl" $col_headers)%b$("$cl" normal $col_fg $col_bg)\n" "${arr_hcache[@]}"
			else
				printf "%s\n" "${arr_hcache[@]}"
			fi
		fi
		if ((${#arr_mcache[@]})); then # print members
			if ((xclude_member_opts)); then
				arr_mcache=( "${arr_mcache[@]%% *}" )
			fi
			IFS="${delim:=$default_delim}"
			if ((colorize)); then
				printf "$("$cl" $col_members)%s$("$cl" normal $col_fg $col_bg)" "${arr_mcache[*]}"
			else
				printf "%s" "${arr_mcache[*]}"
			fi
			IFS="$oIFS"
			printf "\n"
		fi
		if ((show_count)); then # print counters
			if ((glob_search || regex_search || opt_int_search)); then
				if ((colorize)); then
					printf "$("$cl" $col_match)Match count$("$cl" normal $col_fg $col_bg):\
 $("$cl" bold $col_match)%d$("$cl" normal $col_fg $col_bg)\n" $match_count
				else
					printf "Match count: %d\n" $match_count
				fi
			fi
			if ((glob_xclude_element || regex_xclude_element)); then
				if ((colorize)); then
					printf "$("$cl" $col_match)Exclude count$("$cl" normal $col_fg $col_bg):\
 $("$cl" bold $col_match)%d$("$cl" normal $col_fg $col_bg)\n" $xclude_count
				else
					printf "Exclude count: %d\n" $xclude_count
				fi
			fi
			if ((colorize)); then
				printf "$("$cl" bold $col_highlight)Member count$("$cl" normal $col_fg $col_bg):\
 $("$cl" bold $col_members)%d$("$cl" normal $col_fg $col_bg)\n" $member_count
			else
				printf "Member count: %d\n" $member_count
			fi
		fi
	fi
done

# print global counters
if ((count_sets || calc_mem || sets_total || exclude_set)); then
	printf "\n"
	if ((count_sets)); then
		if ((colorize)); then
			printf "$("$cl" bold $col_highlight)Count$("$cl" normal $col_fg $col_bg) of all\
 $("$cl" bold $col_set_count)matched sets$("$cl" normal $col_fg $col_bg):\
 $("$cl" bold $col_set_count)%d$("$cl" normal $col_fg $col_bg)\n" $set_count
		else
			printf "Count of all matched sets: %d\n" $set_count
		fi
		if ((exclude_set)); then
			if ((colorize)); then
				printf "$("$cl" bold $col_highlight)Count$("$cl" normal $col_fg $col_bg) of all\
 $("$cl" bold $col_match)excluded sets$("$cl" normal $col_fg $col_bg):\
 $("$cl" bold $col_match)%d$("$cl" normal $col_fg $col_bg)\n" $found_sxclude
			else
				printf "Count of all excluded sets: %d\n" $found_sxclude
			fi
		fi
	fi
	if ((sets_total)); then
		if ((colorize)); then
			printf "$("$cl" bold $col_highlight)Count$("$cl" normal $col_fg $col_bg) of all\
 $("$cl" bold $col_set_total)traversed sets$("$cl" normal $col_fg $col_bg):\
 $("$cl" bold $col_set_total)%d$("$cl" normal $col_fg $col_bg)\n" $sets_sum
		else
			printf "Count of all traversed sets: %d\n" $sets_sum
		fi
	fi
	if ((calc_mem)); then
		if ((colorize)); then
			printf "$("$cl" bold $col_memsize)Total memory size$("$cl" normal $col_fg $col_bg)\
 of all matched sets: $("$cl" bold $col_memsize)%d$("$cl" normal $col_fg $col_bg)\n" $mem_total
		else
			printf "Total memory size of all matched sets: %d\n" $mem_total
		fi
	fi
fi
}

# -----------------------------------------------------------------
# main
# -----------------------------------------------------------------

# load config file
if [[ $config_file && -r $config_file ]]; then
	. "$config_file" || {
		ex_err "Error while loading configuration file: \`$config_file'."
	}
fi

# parse cmd-line options
while (($#)); do
	case "$1" in
		-\?|-h) printf "%s\n" "
    ipset set listing wrapper script

ipset_list [option [opt-arg]] [set-name-glob] [...]

ipset_list {-?|-h} | -v
ipset_list [-i|-r|-s|-Co|-T|-Xo] [-d char] [-To value]
    [-Fg|-Fr pattern] [-Xg|-Xr pattern]
    [-Oi option-glob:[!|<|>|<=|>=]value] [...] -- set-name
ipset_list [-n|-c|-Ca|-Co|-Cs|-T|-Tm|-Ts|-Xs] [-To value]
    [-Fh header-glob:value-glob] [...] [-Fg|-Fr pattern]
    [-Ht type-glob] [-Hi glob:[!|<|>|<=|>=]value] [...]
    [-Hr|-Hs|-Hv [!|<|>|<=|>=]value] [-Mc [!|<|>|<=|>=]value] [...]
    [-Oi option-glob:[!|<|>|<=|>=]value] [...]
    [-Xs set-name-glob] [...] -- [set-name-glob] [...]
ipset_list [-t|-c|-Ca|-Co|-Cs|-T|-Tm|-Ts] [-To value]
    [-Fh header-glob:value-glob] [...]
    [-Fi header-glob:[!|<|>|<=|>=]value] [...]
    [-Fg|-Fr pattern] [-Ht type-glob] [-Hi glob:[!|<|>|<=|>=]value] [...]
    [-Hr|-Hs|-Hv [!|<|>|<=|>=]value] [-Mc [!|<|>|<=|>=]value] [...]
    [-Oi option-glob:[!|<|>|<=|>=]value] [...]
    [-Xh header-glob:value-glob] [...]
    [-Xs set-name-glob] [...] -- [set-name-glob] [...]
ipset_list [-a|-c|-m|-r|-s|-Ca|-Co|-Cs|-T|-Tm|-Ts|-Xo] [-d char] [-To value]
    [-Fh header-glob:value-glob] [...]
    [-Fi header-glob:[!|<|>|<=|>=]value] [...]
    [-Fg|-Fr pattern] [-Ht type-glob] [-Hi glob:[!|<|>|<=|>=]value] [...]
    [-Hr|-Hs|-Hv [!|<|>|<=|>=]value] [-Mc [!|<|>|<=|>=]value] [...]
    [-Oi option-glob:[!|<|>|<=|>=]value] [...]
    [-Xh header-glob:value-glob] [...]
    [-Xg|-Xr pattern] [-Xs set-name-glob] [...] -- [set-name-glob] [...]
ipset_list - [-r|-s|-G] [-d delim] [-To value] --

options:
-            interactive mode.
-a           show all information but with default delim (whitespace).
-c           calculate members and match sum.
-d delim     delimiter character for separating member entries.
-h|-?        show this help text.
-i           show only the members of a single set.
-m           show set members.
-n           show set names only.
-r           try to resolve ip addresses in the output (slow!).
-s           print elements sorted (if supported by the set type).
-t           show set headers only.
-v           version information.
-Ca          enable all counters (shortcut for -c -Cs -Ts -Tm).
-Co          colorize output (requires \`cl').
-Cs          count amount of matching sets.
-Fg pattern  match on members using a [ext]glob pattern.
-Fr pattern  match on members using a regex (=~ operator) pattern.
-Fh header-glob:value-glob [...]
    show sets containing one or more [ext]glob matching headers.
-Fi header-glob:[!|<|>|<=|>=]value [...]
    show sets matching one or more integer valued header entries.
-G           when in interactive mode, generate command-line.
-Hi header-glob:[!|<|>|<=|>=]value [...]
    match integer valued entries of the \`Header' header.
-Ht set-type-glob       match on set type.
-Hr [!|<|>|<=|>=]value  match on number of references (value=int).
-Hs [!|<|>|<=|>=]value  match on size in memory (value=int).
-Hv [!|<|>|<=|>=]value  match on revision number (value=int).
-Mc [!|<|>|<=|>=]value [...]  match on member count (value=int).
-Oi option-glob:[!|<|>|<=|>=]value [...] match member option values
    (value=int|0xhex[/0xhex]|hex:[!|<|>|<=|>=]hex).
-T element [...]  test if element is in set (\`ipset test n element\`).
-Tm          calculate total memory usage of all matching sets.
-To          set timeout value (int) for read (listing sets).
-Ts          count amount of traversed sets.
-Xo          suppress display of member options.
-Xh header-glob:value-glob [...]
    exclude one or more [ext]glob matching header entries.
-Xg pattern  exclude members matching a [ext]glob pattern.
-Xr pattern  exclude members matching a regex pattern.
-Xs pattern  exclude sets matching a [ext]glob pattern.
--           stop further option processing.
"
			exit 0
		;;
		-) iactive=1 # interactive mode
		;;
		-a) show_all=1 # like `ipset list', but with $delim as delim
		;;
		-c) show_count=1 # show sum of member entries
		;;
		-i) isolate=1 # show only members of a single set
		;;
		-m) show_members=1 # show set members
		;;
		-n) names_only=1 # only list set names
		;;
		-t) headers_only=1 # show only set headers
		;;
		-s|-r) arr_par[i++]="$1" # ipset sort & resolve options are passed on
		;;
		-d) # delimiter char for separating member entries
			[[ $2 ]] || ex_miss_optarg $1 "delim character"
			if ((${#2} > 1)); then
				ex_err "Only one character is allowed as delim"
			fi
			delim="$2" global_delim="$2"
			shift
		;;
		-o) if [[ $2 != plain ]]; then
				ex_err "Only plain output is supported"
			fi
		;;
		-Ca) # shortcut for -c -Cs -Ts -Tm
			show_count=1 count_sets=1 calc_mem=1 sets_total=1
		;;
		-Cs) count_sets=1 # calculate total count of matching sets
		;;
		-Co) colorize=1 global_colorize=1 # colorize the output (requires cl)
		;;
		-Fg) glob_search=1 # find entry with globbing pattern
			[[ $2 ]] || ex_miss_optarg $1 "glob pattern"
			str_search="$2"
			shift
		;;
		-Fr) regex_search=1 # find entry with regex pattern
			[[ $2 ]] || ex_miss_optarg $1 "regex pattern"
			if ! test_regex "$2"; then
				ex_err "Invalid regex pattern \`$2'."
			fi
			str_search="$2"
			shift
		;;
		-G) generate_cmdline=1 global_gen_cmd=1 # in interactive mode generate the cmd-line for ipset_list
		;;
		-Oi) let opt_int_search+=1 # match member option values
			[[ $2 ]] || ex_miss_optarg $1 "pattern"
			if [[ $2 = *:* ]] && is_compare_str_complex "${2#*:}"; then
				arr_opt_int_search[y++]="$2"
				shift
			else
				ex_err "Invalid format of member options expression: \`$2'. Expecting: \`glob:[!|<|>|<=|>=]value'"
			fi
		;;
		-Fh) let match_on_header+=1 # show only sets, which contain a matching header entry
			[[ $2 ]] || ex_miss_optarg $1 "header pattern"
			if [[ $2 = *:* ]]; then
				arr_hsearch[x++]="$2"
				shift
			else
				ex_err "Invalid format of header descriptor: \`$2'. Expecting: \`*:*'"
			fi
		;;
		-Fi) let match_on_header+=1 # show only sets, containing a matching (int compare) header entry
			[[ $2 ]] || ex_miss_optarg $1 "header pattern"
			if [[ $2 = *:* ]] && is_compare_str "${2#*:}"; then
				arr_hsearch_int[idx++]="$2"
				shift
			else
				ex_err "Invalid format of header descriptor: \`$2'. Expecting: \`name:[!|<|>|<=|>=]value'"
			fi
		;;
		-Hi) let match_on_header+=1 # match on name + integer (digit & xdigit) inside of headers 'Header' flag
			[[ $2 ]] || ex_miss_optarg $1 "header pattern"
			if [[ $2 = *:?(\!|<|>|<=|>=)@(+([[:digit:]])|0[xX]+([[:xdigit:]])) ]]; then
				arr_hsearch_xint[${#arr_hsearch_xint[@]}]="$2"
				shift
			else
				ex_err "Invalid format of headers \'Header' flag descriptor: \`$2'. Expecting: \`name:[!|<|>|<=|>=]value'"
			fi
		;;
		-Hr) let match_on_header+=1 # shortcut for -Fi References:...
			[[ $2 ]] || ex_miss_optarg $1 "header pattern"
			if is_compare_str "$2"; then
				arr_hsearch_int[idx++]="References:$2"
				shift
			else
				ex_err "Invalid format of references header descriptor: \`$2'. Expecting: \`[!|<|>|<=|>=]value'"
			fi
		;;
		-Hs) let match_on_header+=1 # shortcut for -Fi "Size in Memory:..."
			[[ $2 ]] || ex_miss_optarg $1 "header pattern"
			if is_compare_str "$2"; then
				arr_hsearch_int[idx++]="Size in memory:$2"
				shift
			else
				ex_err "Invalid format of memsize header descriptor: \`$2'. Expecting: \`[!|<|>|<=|>=]value'"
			fi
		;;
		-Ht) let match_on_header+=1 # shortcut for -Fh Type:x:y
			[[ $2 ]] || ex_miss_optarg $1 "header pattern"
			if [[ $2 = *:* ]]; then
				arr_hsearch[x++]="Type:$2"
				shift
			else
				ex_err "Invalid format of set type descriptor: \`$2'. Expecting: \`*:*'."
			fi
		;;
		-Hv) let match_on_header+=1 # shortcut for -Fi Revision:...
			[[ $2 ]] || ex_miss_optarg $1 "header pattern"
			if is_compare_str "$2"; then
				arr_hsearch_int[idx++]="Revision:$2"
				shift
			else
				ex_err "Invalid format of revision header descriptor: \`$2'. Expecting: \`[!|<|>|<=|>=]value'"
			fi
		;;
		-Mc) do_count=1 # match on the count of members
			[[ $2 ]] || ex_miss_optarg $1 "value pattern"
			if is_compare_str "$2"; then
				arr_match_on_msum[${#arr_match_on_msum[@]}]="$2"
				shift
			else
				ex_err "Invalid format of match on member count value: \`$2'. Expecting: \`[!|<|>|<=|>=]value'"
			fi
		;;
		-T) let test_element+=1 # test precence in set via `ipset test elem`
			[[ $2 ]] || ex_miss_optarg $1 "element"
			arr_test_elem[${#arr_test_elem[@]}]="$2"
			shift
		;;
		-To) # set the timeout for read (limited to integer)
			[[ $2 ]] || ex_miss_optarg $1 "value"
			set_tmout="$2" global_tmout="$2"
			shift
		;;
		-Tm) calc_mem=1 # caculate total memory usage of all matching sets
		;;
		-Ts) sets_total=1 # caculate sum of all traversed sets
		;;
		-Xh) exclude_header=1 # don't show certain headers
			[[ $2 ]] || ex_miss_optarg $1 "header pattern"
			if [[ $2 = *:* ]]; then
				arr_hxclude[${#arr_hxclude[@]}]="$2"
				shift
			else
				ex_err "Invalid format of header descriptor: \`$2'. Expecting: \`*:*'"
			fi
		;;
		-Xg) glob_xclude_element=1 # suppress printing of matching members using a globbing pattern
			[[ $2 ]] || ex_miss_optarg $1 "glob pattern"
			str_xclude="$2"
			shift
		;;
		-Xr) regex_xclude_element=1 # suppress printing of matching members using a regex pattern
			[[ $2 ]] || ex_miss_optarg $1 "regex pattern"
			if ! test_regex "$2"; then
				ex_err "Invalid regex pattern \`$2'."
			fi
			str_xclude="$2"
			shift
		;;
		-Xo) xclude_member_opts=1 # don't show elements options
		;;
		-Xs) exclude_set=1 # don't show certain sets
			[[ $2 ]] || ex_miss_optarg $1 "set name ([ext]glob pattern)"
			arr_sxclude[${#arr_sxclude[@]}]="$2"
			shift
		;;
		-\!|-f) ex_err "Unsupported option: \`$1'"
		;;
		-v) pm "$me version $version"
			exit 0
		;;
		--) break
		;;
		*) break
	esac
	shift
done

# validate value of colorize
if [[ ${colorize:=0} != [01] ]]; then
	ex_err "Value of variable \`colorize' \`$colorize' is not 0 or 1"
fi

# validate set_tmout and iactive_tmout variables
for opt in set_tmout iactive_tmout; do
	if ! is_int "${!opt:-0}"; then
		ex_err "Value \`${!opt}' of variable \`$opt' is not an integer"
	fi
done

# check for ipset program and version
while :; do
	[[ $ipset ]] && command -v "$ipset" &>/dev/null && break
	[[ -x ${ipset:-$(command -v ipset)} ]] && ipset="$(command -v ipset)" && break
	[[ -x ${ipset:=/sbin/ipset} ]] && break
	ex_err "ipset binary \`$ipset' does not exist, or is not executable. Check \`ipset' variable"
done
ips_version="$("$ipset" version)"
ips_version="${ips_version#ipset v}"
ips_version="${ips_version%%.*}"
if ! is_int "$ips_version"; then
	ex_err "Failed retrieving ipset version. expected digits, got: \`$ips_version'"
fi
if ((ips_version < 6)); then
	ex_err "Found version \`$ips_version' - ipset versions from 6.x and upwards are supported"
fi

# sets to work on (no arg means all sets)
idx=0
arr_sets=()
while IFS=$'\n' read -r; do
	arr_sets[idx++]="$REPLY"
done < <("$ipset" list -n)
if ! ((${#arr_sets[@]})); then
	ex_err "Cannot find any sets"
fi

# remember sets - interactive mode may modify arr_sets()
all_sets=( "${arr_sets[@]}" )

# ok, let's go!
if ((iactive)); then # interactive mode
	if ! [[ $dialog_prog ]]; then # see if and what dialog prog we have
		while :; do
			command -v dialog &>/dev/null && \
				[[ $(dialog --version) != Version:+([[:blank:]])@(0.+([[:digit:]])|1.0|1.1)-* ]] && \
				dialog_prog="$(command -v dialog)" && break
			command -v whiptail &>/dev/null && dialog_prog="$(command -v whiptail)" && break
		done
		if ! [[ $dialog_prog ]]; then
			ex_err "No dialog program found! Check \`dialog_prog' variable, or make sure either dialog, or whiptail can be found in PATH."
		fi
	else
		if [[ $dialog_prog = @(dialog|whiptail) ]]; then # correctly defined, but available in $PATH?
			if ! command -v $dialog_prog &>/dev/null; then
				ex_err "No dialog program found! Check \`dialog_prog' variable, or make sure either dialog, or whiptail can be found in PATH."
			fi
		elif [[ $dialog_prog = */@(dialog|whiptail) ]]; then # correctly defined, but does it exist/executable?
			if ! [[ -x $dialog_prog ]]; then
				ex_err "No dialog program found! Check \`dialog_prog' variable, or make sure either dialog, or whiptail can be found in PATH."
			fi
		else
			ex_err "No dialog program found! Check \`dialog_prog' variable, or make sure either dialog, or whiptail can be found in PATH."
		fi
	fi
	if [[ $dialog_prog = *dialog ]]; then
		if [[ $($dialog_prog --version) = Version:+([[:blank:]])@(0.+([[:digit:]])|1.0|1.1)-* ]]; then
			ex_err "Detected unsupported version of the dialog program! Please upgrade to at least 1.2, or use whiptail."
		fi
	fi
	# check for tput program
	while :; do
		[[ $tput ]] && command -v "$tput" &>/dev/null && break
		[[ -x ${tput:-$(command -v tput)} ]] && tput="$(command -v tput)" && break
		[[ -x ${tput:=/usr/bin/tput} ]] && break
		unset tput
	done
	# set some defaults if unset
	: ${w_height:=0}
	: ${w_with:=0}
	: ${l_height:=0}

	# check for int values
	for opt in w_height w_with l_height; do
		if ! is_int "${!opt}"; then
			ex_err "Value of \`$opt' is not an integer"
		fi
	done
	# if 0 and tput is present, adjust window measures automatically
	if (( w_height == 0 )) && [[ $tput ]]; then
		w_height=$( "$tput" lines )
	fi
	if (( w_with == 0 )) && [[ $tput ]]; then
		w_with=$( "$tput" cols )
	fi
	if (( l_height == 0 )) && [[ $tput ]]; then
		l_height=$(( $( "$tput" lines ) - 10 ))
	fi
	# ready to run interactive mode
	while (($? == 0)); do
		# some variables need to be reset on each loop
		member_count=0 match_count=0 do_count=0 show_count=0 calc_mem=0 count_sets=0 sets_total=0
		show_all=0 show_members=0 headers_only=0 names_only=0 isolate=0
		match_on_header=0 glob_search=0 regex_search=0 opt_int_search=0 test_element=0
		exclude_header=0 glob_xclude_element=0 regex_xclude_element=0 exclude_set=0 xclude_member_opts=0
		generate_cmdline=$global_gen_cmd colorize=$global_colorize delim="$global_delim" set_tmout=$global_tmout
		arr_hsearch=() arr_hsearch_int=() arr_hsearch_xint=() arr_match_on_msum=() arr_opt_int_search=()
		arr_test_elem=() arr_hxclude=() arr_sxclude=()

		# run interactive window until user cancels
		interactive_mode
	done
	exit 0
else
	# normal mode
	main "$@"
fi

